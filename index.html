<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CKA Exam Study Guide | Certified Kubernetes Administrator (CKA) Preparation &amp; Cheat Sheet</title>
  <meta name="description"
    content="Free CKA study guide: cluster architecture, scheduling, networking, storage, RBAC, troubleshooting. Commands, YAML examples &amp; diagrams for Certified Kubernetes Administrator exam.">
  <meta name="keywords"
    content="CKA, Certified Kubernetes Administrator, Kubernetes certification, CKA exam, CKA study guide, CKA preparation, Kubernetes admin, kubectl, K8s certification">
  <meta name="author" content="CKA Study Guide">
  <meta name="robots" content="index, follow">
  <!-- Replace with your real page URL when you publish the site -->
  <link rel="canonical" href="https://example.com/cka-preparation.html">
  <!-- Open Graph -->
  <meta property="og:type" content="website">
  <meta property="og:title" content="CKA Exam Study Guide | Certified Kubernetes Administrator Preparation">
  <meta property="og:description"
    content="Free CKA study guide with commands, YAML examples and diagrams. Covers cluster architecture, scheduling, networking, storage, security and troubleshooting for the CKA exam.">
  <meta property="og:url" content="https://example.com/cka-preparation.html">
  <meta property="og:locale" content="en_US">
  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="CKA Exam Study Guide | Certified Kubernetes Administrator">
  <meta name="twitter:description"
    content="Free CKA study guide: commands, YAML snippets and diagrams for Certified Kubernetes Administrator (CKA) exam preparation.">
  <meta name="theme-color" content="#ffffff">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Outfit:wght@400;500;600;700&display=swap"
    rel="stylesheet">
  <style>
    :root {
      --bg: #ffffff;
      --surface: #f6f8fa;
      --surface2: #eaeef2;
      --text: #1f2328;
      --text-muted: #656d76;
      --accent: #1a7f37;
      --accent2: #0969da;
      --border: #d0d7de;
      --code-bg: #f6f8fa;
      --nav-width: 260px;
      --content-max: 720px;
      --header-h: 40px;
    }

    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }

    html {
      font-size: 16px;
      overflow: hidden;
      /* Prevent default scrollbars, main content scrolls independently */
    }

    /* Content blocks: only one open at a time */
    .content-block {
      display: none;
      overflow: hidden;
      animation: blockOpen 0.4s ease-out;
    }

    .content-block.is-open {
      display: block;
    }

    @keyframes blockOpen {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    body {
      margin: 0;
      font-family: 'Outfit', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg);
      color: var(--text);
      line-height: 1.65;
      -webkit-font-smoothing: antialiased;
      overflow: hidden;
      /* Double ensure no body scroll */
    }

    .site-header {
      position: sticky;
      top: 0;
      z-index: 100;
      height: var(--header-h);
      background: var(--surface);
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      padding: 0 1.25rem;
    }

    .site-header h1 {
      margin: 0;
      font-size: clamp(1rem, 2.5vw, 1.25rem);
      font-weight: 600;
      color: var(--text);
    }

    .site-header .badge {
      margin-left: 0.5rem;
      font-size: 0.7rem;
      padding: 0.2em 0.5em;
      background: var(--accent);
      color: var(--bg);
      border-radius: 4px;
      font-weight: 600;
    }

    .header-controls {
      margin-left: auto;
      display: flex;
      gap: 0.5rem;
    }

    .icon-btn {
      padding: 0.4rem;
      background: transparent;
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 1.1rem;
      line-height: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }

    .icon-btn:hover {
      background: var(--surface2);
      color: var(--text);
    }

    .nav-toggle {
      display: none;
      /* Handled by header-controls on desktop, this is for mobile override logic if needed */
    }

    /* Layout toggles */
    .layout.nav-hidden nav {
      display: none;
    }

    .layout.sidebar-hidden .right-sidebar {
      display: none;
    }

    /* Make main content expand when sidebars are hidden */
    .layout.nav-hidden main {
      padding-left: clamp(1.5rem, 5vw, 4rem);
      /* Center it a bit more when wide */
    }

    .layout {
      display: flex;
      min-height: calc(100vh - var(--header-h));
    }

    nav {
      position: sticky;
      top: var(--header-h);
      width: var(--nav-width);
      min-width: var(--nav-width);
      height: calc(100vh - var(--header-h));
      overflow-y: auto;
      background: var(--surface);
      border-right: 1px solid var(--border);
      padding: 1.5rem 1rem;
      /* More padding for breathing room */
      flex-shrink: 0;
      /* Scrollbar styling */
      scrollbar-width: thin;
      scrollbar-color: var(--border) transparent;
    }

    nav::-webkit-scrollbar {
      width: 6px;
    }

    nav::-webkit-scrollbar-thumb {
      background-color: var(--border);
      border-radius: 3px;
    }

    nav a {
      display: block;
      padding: 0.6rem 1rem;
      margin-bottom: 0.1rem;
      color: var(--text-muted);
      text-decoration: none;
      font-size: 0.9rem;
      font-weight: 500;
      border-radius: 6px;
      border-left: none;
      transition: all 0.2s ease-in-out;
      position: relative;
    }

    nav a:hover,
    nav a.active {
      color: var(--accent2);
      background: var(--surface2);
      transform: translateX(3px);
      font-weight: 600;
    }

    /* Submenu styling */
    .nav-submenu {
      display: none;
      margin-bottom: 0.5rem;
      padding-left: 0.5rem;
    }

    .nav-item.active .nav-submenu {
      display: block;
      animation: fadeIn 0.3s ease;
    }

    .nav-sub-link {
      font-size: 0.8rem !important;
      padding: 0.35rem 1rem 0.35rem 1.5rem !important;
      color: var(--text-muted) !important;
      opacity: 0.85;
      font-weight: 400 !important;
      background: transparent !important;
    }

    .nav-sub-link:hover {
      color: var(--accent) !important;
      background: var(--surface2) !important;
      opacity: 1;
      transform: translateX(2px) !important;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(-5px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    nav .nav-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 0.5rem 0.5rem;
      /* Aligned with new padding */
      border-bottom: 2px solid var(--surface2);
      /* Subtle divider */
      margin-bottom: 1rem;
    }

    nav .nav-section {
      font-size: 0.75rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text);
      opacity: 0.8;
    }

    .nav-close {
      display: none;
      padding: 0.4rem;
      font-size: 1.25rem;
      line-height: 1;
      background: var(--surface2);
      border: none;
      border-radius: 50%;
      /* Circle button */
      color: var(--text);
      cursor: pointer;
      transition: background 0.2s;
    }

    .nav-close:hover {
      background: var(--border);
    }

    main {
      flex: 1;
      min-width: 0;
      padding: clamp(1.25rem, 4vw, 2.5rem) clamp(1.5rem, 5vw, 3rem) 4rem;
      /* Allow main content to scroll independently */
      height: calc(100vh - var(--header-h));
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: var(--border) transparent;
    }

    main::-webkit-scrollbar {
      width: 8px;
    }

    main::-webkit-scrollbar-thumb {
      background-color: var(--border);
      border-radius: 4px;
    }

    .page-title {
      font-size: clamp(1.5rem, 4vw, 2rem);
      font-weight: 700;
      margin: 0 0 0.35rem;
      color: var(--text);
    }

    .subtitle {
      color: var(--text-muted);
      margin-bottom: 2rem;
      font-size: clamp(0.9rem, 1.5vw, 1.05rem);
      line-height: 1.5;
    }

    h2 {
      font-size: clamp(1.25rem, 2.5vw, 1.5rem);
      font-weight: 600;
      margin: 2.25rem 0 0.85rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid var(--border);
      color: var(--accent);
      scroll-margin-top: calc(var(--header-h) + 0.5rem);
    }

    h3 {
      font-size: clamp(1.05rem, 2vw, 1.2rem);
      font-weight: 600;
      margin: 1.5rem 0 0.6rem;
      color: var(--text);
    }

    h4 {
      font-size: 1rem;
      margin: 1rem 0 0.4rem;
      color: var(--text-muted);
      font-weight: 500;
    }

    p {
      margin: 0.65rem 0;
      max-width: 70ch;
    }

    ul,
    ol {
      margin: 0.65rem 0;
      padding-left: 1.5rem;
      max-width: 70ch;
    }

    li {
      margin: 0.3rem 0;
    }

    pre,
    code {
      font-family: 'JetBrains Mono', 'Consolas', monospace;
    }

    code {
      background: rgba(175, 184, 193, 0.2);
      border-radius: 6px;
      padding: 0.2em 0.4em;
      font-size: 0.875em;
      color: var(--text);
    }

    pre {
      padding: 1.25rem;
      overflow-x: auto;
      margin: 1.5rem 0;
      font-size: 0.9rem;
      max-width: 100%;
      background: #0d1117;
      /* High contrast dark bg */
      color: #c9d1d9;
      border: 1px solid #30363d;
      border-radius: 12px;
      box-shadow: 0 12px 24px -10px rgba(0, 0, 0, 0.3);
      position: relative;
    }

    /* Adding a subtle 'window controls' look to all code blocks */
    pre::before {
      content: "•••";
      display: block;
      font-size: 1.2rem;
      letter-spacing: -2px;
      color: #30363d;
      margin-bottom: 0.75rem;
      line-height: 0.5;
    }

    pre code {
      padding: 0;
      background: none;
      border: none;
      border-radius: 0;
      color: inherit;
      font-size: inherit;
    }

    .card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1.25rem;
      margin: 1rem 0;
      max-width: 70ch;
    }

    .snippet-label {
      font-size: 0.75rem;
      color: var(--text-muted);
      margin-bottom: 0.35rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }

    .diagram {
      margin: 1.5rem 0;
      padding: 1.5rem;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: var(--surface);
      text-align: center;
    }

    .diagram svg {
      display: block;
      max-width: 100%;
      height: auto;
      margin: 0 auto;
    }

    .diagram figcaption {
      font-size: 0.8rem;
      color: var(--text-muted);
      margin-top: 0.75rem;
      padding-top: 0.75rem;
      border-top: 1px solid var(--border);
      text-align: center;
      max-width: 56ch;
      margin-left: auto;
      margin-right: auto;
    }

    .step-list {
      list-style: none;
      padding-left: 0;
      max-width: 70ch;
    }

    .step-list li {
      position: relative;
      padding-left: 1.5rem;
      margin: 0.5rem 0;
    }

    .step-list li::before {
      content: "→";
      position: absolute;
      left: 0;
      color: var(--accent);
      font-weight: 600;
    }

    .site-footer {
      padding: 1rem 1.5rem;
      border-top: 1px solid var(--border);
      background: var(--surface);
      font-size: 0.8rem;
      color: var(--text-muted);
      text-align: center;
    }

    /* ── Responsive breakpoints ─────────────────────────────────────── */

    /* Large desktop — hide right sidebar when screen is tight */
    @media (max-width: 1400px) {
      .right-sidebar {
        display: none;
      }
    }

    /* Tablet landscape */
    @media (max-width: 992px) {
      nav {
        width: 220px;
        min-width: 220px;
      }

      main {
        padding-left: 1.5rem;
        padding-right: 1.5rem;
      }

      .cheat-grid {
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      }
    }

    /* Tablet portrait & small laptop — collapsing nav becomes a drawer */
    @media (max-width: 768px) {
      .nav-toggle {
        display: block;
      }

      .nav-close {
        display: block;
      }

      nav {
        display: none;
        /* Hidden by default on mobile */
        position: fixed;
        top: var(--header-h);
        left: 0;
        right: 0;
        width: 100%;
        min-width: 0;
        height: auto;
        max-height: calc(100vh - var(--header-h));
        /* Use full viewport height minus header */
        z-index: 999;
        overflow-y: auto;
        /* Ensure scrolling */
        -webkit-overflow-scrolling: touch;
        /* Smooth scrolling on iOS */
        border-right: none;
        border-bottom: 1px solid var(--border);
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.18);
        background: var(--surface);
      }

      nav.is-open {
        display: block;
        /* Show when open */
        animation: slideDown 0.25s ease-out forwards;
      }

      @keyframes slideDown {
        from {
          opacity: 0;
          transform: translateY(-10px);
        }

        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .layout {
        flex-direction: column;
      }

      main {
        padding: 1.25rem 1rem 3rem;
      }

      .cheat-grid {
        grid-template-columns: 1fr;
      }

      .diagram {
        overflow-x: auto;
      }

      .card {
        max-width: none;
      }
    }

    /* Mobile */
    /* Copy Button - Global */
    .copy-btn {
      position: sticky;
      float: right;
      top: 0;
      right: 0;
      margin-top: -0.5rem;
      margin-right: -0.5rem;
      background: transparent;
      border: 1px solid transparent;
      color: #8b949e;
      border-radius: 4px;
      padding: 0.25rem;
      cursor: pointer;
      opacity: 0;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      backdrop-filter: blur(2px);
    }

    pre:hover .copy-btn {
      opacity: 1;
    }

    .copy-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      color: #f0f6fc;
      border-color: rgba(255, 255, 255, 0.15);
    }

    .copy-btn.copied {
      color: #3fb950;
      border-color: rgba(63, 185, 80, 0.4);
      background: rgba(63, 185, 80, 0.1);
    }

    /* Mobile */
    /* Mobile override for pre */
    @media (max-width: 480px) {
      :root {
        --header-h: 50px;
      }

      .site-header {
        padding: 0 0.75rem;
      }

      .site-header h1 {
        font-size: 0.95rem;
      }

      main {
        padding: 0.75rem 0.65rem 2.5rem;
      }

      pre {
        padding: 0.65rem;
        font-size: 0.78rem;
        margin: 0.5rem -0.25rem;
        border-radius: 6px;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
      }

      /* Ensure copy btn is visible on touch for mobile if needed */
      pre .copy-btn {
        opacity: 1;
        background: rgba(255, 255, 255, 0.05);
      }

      h2 {
        font-size: 1.3rem;
      }

      h3 {
        font-size: 1.05rem;
      }

      .cheat-card {
        padding: 0.75rem;
      }

      .cheat-card pre {
        font-size: 0.75rem;
      }

      .mock-question,
      .playground-scenario {
        padding: 0.9rem 1rem;
      }
    }

    /* Challenge Mode CSS */
    .challenge-toggle-wrapper {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-right: 1rem;
    }

    .challenge-label {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--text-muted);
    }

    .toggle-switch {
      position: relative;
      width: 40px;
      height: 20px;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: var(--surface2);
      transition: .4s;
      border-radius: 20px;
      border: 1px solid var(--border);
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 14px;
      width: 14px;
      left: 3px;
      bottom: 2px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }

    input:checked+.slider {
      background-color: var(--accent);
      border-color: var(--accent);
    }

    input:checked+.slider:before {
      transform: translateX(20px);
    }

    /* Challenge Mode Effects */
    /* Challenge Mode Effects */
    body.challenge-mode-active pre code,
    body.challenge-mode-active .diagram svg {
      filter: blur(5px);
      opacity: 0.7;
      pointer-events: none;
      user-select: none;
      transition: all 0.3s ease;
    }

    body.challenge-mode-active pre:hover code,
    body.challenge-mode-active .diagram:hover svg {
      filter: blur(0);
      opacity: 1;
      pointer-events: auto;
      user-select: auto;
    }

    body.challenge-mode-active pre,
    body.challenge-mode-active .diagram {
      position: relative;
    }

    body.challenge-mode-active pre::after,
    body.challenge-mode-active .diagram::after {
      content: "Hover to Reveal";
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 4px;
      font-size: 0.8rem;
      pointer-events: none;
      opacity: 1;
      z-index: 10;
      white-space: nowrap;
    }

    body.challenge-mode-active pre:hover::after,
    body.challenge-mode-active .diagram:hover::after {
      opacity: 0;
    }

    /* Print */
    @media print {

      .site-header,
      nav,
      .nav-toggle,
      .right-sidebar,
      .site-footer {
        display: none !important;
      }

      body {
        background: #fff;
        color: #111;
      }

      main {
        padding: 0;
      }

      .content-block {
        display: block !important;
      }

      .diagram {
        break-inside: avoid;
      }

      pre {
        white-space: pre-wrap;
        word-break: break-word;
      }
    }

    /* Mock exam & playground */
    .mock-question,
    .playground-scenario {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 1.25rem 1.5rem;
      margin: 1rem 0;
    }

    .mock-question h4,
    .playground-scenario h4 {
      margin: 0 0 0.5rem;
      font-size: 1.05rem;
      color: var(--accent2);
    }

    .mock-context,
    .playground-context {
      color: var(--text-muted);
      margin: 0.5rem 0;
    }

    .mock-task,
    .playground-task {
      margin: 0.75rem 0;
      font-weight: 500;
    }

    .solution-toggle,
    .playground-toggle {
      display: inline-block;
      margin: 0.75rem 0 0;
      padding: 0.4rem 0.9rem;
      font-size: 0.9rem;
      font-family: inherit;
      font-weight: 600;
      color: var(--accent);
      background: var(--surface2);
      border: 1px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.15s, color 0.15s;
    }

    .solution-toggle:hover,
    .playground-toggle:hover {
      background: var(--border);
      color: var(--text);
    }

    .mock-solution,
    .playground-solution {
      display: none;
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px dashed var(--border);
    }

    .mock-solution.is-open,
    .playground-solution.is-open {
      display: block;
    }

    .mock-solution pre,
    .playground-solution pre {
      margin: 0.5rem 0 0;
    }

    .playground-links {
      list-style: none;
      padding: 0;
      margin: 1rem 0;
    }

    .playground-links li {
      margin: 0.75rem 0;
      padding: 0.75rem 1rem;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
    }

    .playground-links a {
      font-weight: 600;
      color: var(--accent2);
      text-decoration: none;
    }

    .playground-links a:hover {
      text-decoration: underline;
    }

    .playground-links .link-desc {
      font-size: 0.9rem;
      color: var(--text-muted);
      margin-top: 0.25rem;
    }


    /* ── Cheat Sheet & Syntax Highlighting ────────────────────────── */
    .cheat-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(360px, 1fr));
      gap: 2rem;
      margin: 2.5rem 0;
    }

    .cheat-card {
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 4px 24px rgba(0, 0, 0, 0.06);
      transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
      display: flex;
      flex-direction: column;
    }

    .cheat-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 12px 32px rgba(0, 0, 0, 0.12);
      border-color: var(--accent2);
    }

    .cheat-card-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.6rem;
      background: linear-gradient(to right, var(--surface), var(--surface2));
      border-bottom: 1px solid var(--border);
      padding: 0.85rem 1.25rem;
    }

    .cheat-card-header h4 {
      margin: 0;
      font-size: 1rem;
      font-weight: 700;
      color: var(--text);
      letter-spacing: -0.01em;
    }

    .cheat-card-header::after {
      content: "";
      width: 40px;
      height: 4px;
      background: var(--accent2);
      border-radius: 2px;
      opacity: 0.5;
    }

    .cheat-card-body {
      padding: 0;
      background: #0d1117;
      flex: 1;
    }

    /* Override global pre inside cheat cards to remove extra padding/margin */
    .cheat-card pre {
      margin: 0;
      padding: 1.25rem;
      background: transparent;
      border: none;
      border-radius: 0;
      box-shadow: none;
      font-size: 0.88rem;
      line-height: 1.65;
      overflow-x: auto;
    }

    .cheat-card pre::before {
      display: none;
      /* Hide the window dots in cards as header serves that purpose */
    }

    /* Syntax colouring (Global) */
    .cs-str {
      color: #a5d6ff;
    }

    /* Light Blue */
    .cs-comment {
      color: #8b949e;
      font-style: italic;
    }

    /* Muted Grey */
    .cs-key {
      color: #7ee787;
    }

    /* Green */
    .cs-kw {
      color: #ff7b72;
      font-weight: bold;
    }

    /* Red/Pink */
    .cs-flag {
      color: #79c0ff;
    }

    /* Blue */
    .cs-val {
      color: #d2a8ff;
    }

    /* Purple */
    .cs-section {
      color: #bc8cff;
      font-weight: bold;
      border-bottom: 1px dashed #bc8cff;
    }

    /* Two-column on wide screens */
    @media (min-width: 1400px) {
      .cheat-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    @media (max-width: 768px) {
      .cheat-card pre {
        font-size: 0.8rem;
        padding: 1rem;
      }

      .cheat-grid {
        gap: 1.5rem;
      }
    }

    /* Right sidebar — Quick Links */
    .right-sidebar {
      position: sticky;
      top: var(--header-h);
      width: 240px;
      /* Slightly wider */
      min-width: 240px;
      height: calc(100vh - var(--header-h));
      overflow-y: auto;
      background: var(--surface);
      border-left: 1px solid var(--border);
      padding: 2rem 1.5rem;
      /* More generous padding */
      flex-shrink: 0;
    }

    .right-sidebar .sidebar-title {
      font-size: 0.8rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text);
      opacity: 0.6;
      margin: 0 0 1rem 0.5rem;
      padding-bottom: 0.5rem;
      border-bottom: 2px solid var(--surface2);
    }

    .right-sidebar ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .right-sidebar li {
      margin: 0.25rem 0;
    }

    .right-sidebar a {
      display: block;
      padding: 0.5rem 1rem;
      font-size: 0.9rem;
      color: var(--text-muted);
      text-decoration: none;
      border-radius: 6px;
      transition: all 0.2s ease;
      position: relative;
    }

    .right-sidebar a:hover {
      color: var(--accent);
      background: var(--surface2);
      padding-left: 1.4rem;
      /* Slide effect */
    }

    .right-sidebar .link-note {
      font-size: 0.75rem;
      color: var(--text-muted);
      margin-top: 1.5rem;
      padding: 0.75rem;
      background: var(--surface2);
      border-radius: 6px;
      border: 1px solid var(--border);
      line-height: 1.5;
      font-style: italic;
    }

    /* Terminal Simulator CSS */
    .term-fab {
      position: fixed;
      bottom: 2rem;
      right: 2rem;
      width: 56px;
      height: 56px;
      border-radius: 50%;
      background: var(--accent);
      color: white;
      border: none;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      font-size: 1.5rem;
      font-family: monospace;
      font-weight: bold;
      cursor: pointer;
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .term-fab:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
    }

    .term-container {
      position: fixed;
      bottom: 2rem;
      right: 2rem;
      width: 600px;
      height: 400px;
      background: #1e1e1e;
      border-radius: 8px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      z-index: 1001;
      display: none;
      flex-direction: column;
      border: 1px solid #444;
      font-family: 'Fira Code', 'Courier New', monospace;
      font-size: 0.9rem;
      overflow: hidden;
      transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      transform: translateY(20px);
      opacity: 0;
    }

    .term-container.open {
      display: flex;
      transform: translateY(0);
      opacity: 1;
    }

    /* Mobile Terminal */
    @media (max-width: 640px) {
      .term-container {
        width: 100%;
        height: 50vh;
        bottom: 0;
        right: 0;
        border-radius: 8px 8px 0 0;
      }

      .term-fab {
        bottom: 1.5rem;
        right: 1.5rem;
      }
    }

    .term-header {
      background: #2d2d2d;
      padding: 0.5rem 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #333;
      color: #ccc;
      font-size: 0.8rem;
    }

    .term-controls span {
      margin-left: 1rem;
      cursor: pointer;
      font-weight: bold;
    }

    .term-controls span:hover {
      color: white;
    }

    .term-body {
      flex: 1;
      padding: 1rem;
      color: #d4d4d4;
      overflow-y: auto;
      background: #1e1e1e;
    }

    .term-line {
      margin-bottom: 0.25rem;
      line-height: 1.4;
      white-space: pre-wrap;
    }

    .term-line.output {
      color: #ce9178;
      /* Output color */
      margin-bottom: 0.75rem;
    }

    .term-input-line {
      display: flex;
      align-items: center;
    }

    .prompt {
      color: #4ec9b0;
      margin-right: 0.5rem;
    }

    .term-input {
      background: transparent;
      border: none;
      color: #d4d4d4;
      flex: 1;
      font-family: inherit;
      font-size: inherit;
      outline: none;
    }
  </style>
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "LearningResource",
    "name": "CKA Exam Study Guide | Certified Kubernetes Administrator Preparation",
    "description": "Free study guide for the Certified Kubernetes Administrator (CKA) exam. Covers cluster architecture, scheduling, workloads, networking, storage, security, and troubleshooting with commands, YAML examples and diagrams.",
    "learningResourceType": "Study Guide",
    "educationalLevel": "Professional",
    "teaches": ["Kubernetes", "Container orchestration", "kubectl", "CKA certification", "Cluster administration"],
    "about": [
      { "@type": "Thing", "name": "Certified Kubernetes Administrator" },
      { "@type": "Thing", "name": "Kubernetes" }
    ]
  }
  </script>
</head>

<body>
  <header class="site-header" style="z-index: 2000;">
    <div style="display: flex; align-items: center; gap: 0.5rem; flex: 1; min-width: 0;">
      <button type="button" class="icon-btn" id="toggle-left" title="Toggle Navigation">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
          stroke-linecap="round" stroke-linejoin="round">
          <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
          <line x1="9" y1="3" x2="9" y2="21"></line>
        </svg>
      </button>
      <h1 style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">CKA Study Guide</h1>
      <span class="badge">CKA</span>
    </div>

    <div class="header-controls">
      <!-- Challenge Mode Toggle -->
      <div class="challenge-toggle-wrapper" title="Hide answers to test yourself">
        <span class="challenge-label"
          style="display: none; @media (min-width: 768px) { display: inline; }">Challenge</span>
        <label class="toggle-switch">
          <input type="checkbox" id="challenge-toggle">
          <span class="slider"></span>
        </label>
      </div>

      <button type="button" class="icon-btn" id="toggle-right" title="Toggle Sidebar">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
          stroke-linecap="round" stroke-linejoin="round">
          <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
          <line x1="15" y1="3" x2="15" y2="21"></line>
        </svg>
      </button>
      <button type="button" class="nav-toggle" aria-label="Open menu" id="nav-toggle">☰</button>
    </div>
  </header>
  <div class="layout">
    <nav id="nav" aria-label="Section navigation">
      <div class="nav-header">
        <span class="nav-section">CKA Preparation</span>
        <button type="button" class="nav-close" aria-label="Close menu" id="nav-close">×</button>
      </div>

      <a href="#section-01">01 Introduction</a>
      <a href="#section-02">02 Core Concepts</a>
      <a href="#section-03">03 Scheduling</a>
      <a href="#section-04">04 Logging & Monitoring</a>
      <a href="#section-05">05 Application Lifecycle</a>
      <a href="#section-06">06 Cluster Maintenance</a>
      <a href="#section-07">07 Security</a>
      <a href="#section-08">08 Storage</a>
      <a href="#section-09">09 Networking</a>
      <a href="#section-10">10 Design & Install</a>
      <a href="#section-11">11 kubeadm</a>
      <a href="#section-12">12 Troubleshooting</a>

    </nav>
    <main>
      <header id="intro">
        <h1 class="page-title">Certified Kubernetes Administrator (CKA)</h1>
        <p class="subtitle">Complete reference guide for the CKA exam. Use the navigation to jump between topics.</p>
      </header>

      <!-- 01 Introduction -->
      <h2 id="section-01">01 — Introduction</h2>
      <h3>Course focus</h3>
      <p>This material focuses on the <strong>administration</strong> part of Kubernetes, aligned with the CKA exam.</p>
      <h4>Pre-requisites</h4>
      <ul>
        <li>Docker</li>
        <li>Basics of Kubernetes (Pods, Deployments, Services)</li>
        <li>YAML</li>
        <li>Basic lab environment (e.g. VirtualBox)</li>
      </ul>
      <h4>Exam areas (weighted)</h4>
      <ul>
        <li><strong>Cluster Architecture, Installation & Validation</strong> (25%): Design, install, configure,
          validate, manage HA, etcd, upgrade.</li>
        <li><strong>Workloads & Scheduling</strong> (15%): Deployments, scaling, DaemonSets, resource limits, scheduling
          (manual, node selector, affinity, taints/tolerations), static pods.</li>
        <li><strong>Services & Networking</strong> (20%): Networking model, Services (ClusterIP, NodePort,
          LoadBalancer), DNS, CNI, Ingress.</li>
        <li><strong>Storage</strong> (10%): PV, PVC, StorageClass, volume mounts.</li>
        <li><strong>Troubleshooting</strong> (30%): Application, control plane, worker nodes, network.</li>
        <li>Plus: Security (RBAC, TLS, kubeconfig, NetworkPolicies), Logging/Monitoring, Application Lifecycle
          (rollouts, ConfigMaps, Secrets).</li>
        <li><strong>2025 curriculum additions:</strong> Helm and Kustomize for cluster components; Gateway API (with
          Ingress); CRDs and operators; extension interfaces (CNI, CSI, CRI); CoreDNS; workload autoscaling (HPA);
          PodDisruptionBudgets. See sections 05, 06, 09, and 13.</li>
      </ul>
      <h3>Certification</h3>
      <p>Certified Kubernetes Administrator (CKA): exam curriculum, candidate handbook, and exam tips are published by
        the Linux Foundation / CNCF. Use code <code>KUBERNETES15</code> when registering for CKA or CKAD for a 15%
        discount.</p>

      <!-- 02 Core Concepts -->
      <h2 id="section-02">02 — Core Concepts</h2>

      <h3>Cluster Architecture</h3>
      <p>A Kubernetes cluster consists of a <strong>Control Plane</strong> (the brain) and <strong>Worker Nodes</strong>
        (the muscle).</p>
      <ul>
        <li><strong>Control Plane:</strong> Manages the state of the cluster. It makes global decisions (scheduling),
          detects and responds to cluster events (starting new pods), and stores the cluster configuration.</li>
        <li><strong>Worker Node:</strong> A machine (VM or physical) that runs containerized applications. It hosts the
          Pods and communicates with the control plane via the kubelet.</li>
      </ul>

      <h3>Control Plane Components</h3>

      <h4>kube-apiserver</h4>
      <p>The <strong>front-end</strong> of the Kubernetes control plane. It exposes the Kubernetes API (REST). It is the
        <strong>only</strong> component that communicates directly with <strong>etcd</strong>.
        <br><em>Key function:</em> Authenticates, validates, and processes all REST requests (internal & external). It
        is designed to scale horizontally.
      </p>

      <h4>etcd</h4>
      <p>A consistent and highly-available <strong>key-value store</strong> used as Kubernetes' backing store for all
        cluster data.
        <br><em>Pro Tip:</em> It uses the <strong>RAFT algorithm</strong> for consensus. It is the "single source of
        truth" — if data is in etcd, it exists; otherwise, it does not.
      </p>

      <h4>kube-scheduler</h4>
      <p>Watches for newly created Pods with no assigned node and selects a node for them to run on.
        <br><em>Process:</em>
        <br>1. <strong>Filtering:</strong> Ruling out nodes that don't meet requirements (CPU/RAM, Taints, Affinity).
        <br>2. <strong>Scoring:</strong> Ranking the remaining nodes to find the best fit.
      </p>

      <h4>kube-controller-manager</h4>
      <p>A daemon that runs controller processes. Logically, each controller is a separate process, but they are
        compiled into a single binary.
        <br><em>Responsibility:</em> <strong>Reconciliation Loop</strong>. It continuously watches the <em>current
          state</em> and compares it to the <em>desired state</em>, making changes to match them.
        <br><em>Examples:</em> Node Controller (notices down nodes), Replication Controller (maintains pod count),
        Endpoints Controller.
      </p>

      <h4>cloud-controller-manager</h4>
      <p>Embeds cloud-specific control logic. It lets you link your cluster into your cloud provider's API (e.g., AWS,
        Azure, GCP). It handles things like Node instances (cloud VMs), LoadBalancers, and Routes.</p>

      <h3>Node Components</h3>

      <h4>kubelet</h4>
      <p>An agent that runs on each node. It registers the node with the API server and ensures that containers are
        running in a Pod.
        <br><em>Mechanism:</em> It takes a set of PodSpecs (from API server or static files) and ensures the containers
        described are running and healthy. It does <strong>not</strong> manage containers not created by Kubernetes.
      </p>

      <h4>kube-proxy</h4>
      <p>A network proxy running on each node. It maintains network rules that allow network communication to your Pods
        from inside or outside the cluster.
        <br><em>Implementation:</em> Commonly uses <strong>iptables</strong> or <strong>IPVS</strong> to forward traffic
        to backend Pods (Service abstraction).
      </p>

      <h4>Container Runtime</h4>
      <p>The software responsible for running containers. Kubernetes supports any runtime that adheres to the
        <strong>Container Runtime Interface (CRI)</strong>.
      </p>

      <h3>Docker vs ContainerD (CRI)</h3>
      <p><strong>Fact:</strong> Kubernetes removed the "dockershim" in v1.24. This means Kubernetes can no longer use
        the Docker Engine directly as a runtime. It now uses <strong>containerd</strong> or <strong>CRI-O</strong> via
        the CRI.</p>
      <ul>
        <li><strong>containerd:</strong> An industry-standard container runtime. It was part of Docker but is now
          independent.</li>
        <li><strong>crictl:</strong> A CLI tool for CRI-compatible container runtimes. Used mainly for debugging on the
          node.</li>
        <li><strong>nerdctl:</strong> A Docker-compatible CLI for containerd (supports <code>docker run</code> style
          commands).</li>
      </ul>
      <div class="snippet-label">Useful crictl commands</div>
      <pre><code>crictl ps -a                        # list all containers
crictl images                       # list images
crictl pods                         # list pods (sandbox containers)
crictl logs &lt;container-id&gt;          # view logs directly from runtime
crictl inspect &lt;container-id&gt;       # deep dive into container status</code></pre>

      <figure class="diagram">
        <svg viewBox="0 0 700 320" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">
          <defs>
            <marker id="arrow" markerWidth="8" markerHeight="8" refX="6" refY="4" orient="auto">
              <path d="M0 0 L8 4 L0 8 Z" fill="#0969da" />
            </marker>
          </defs>
          <!-- Title -->
          <text x="350" y="28" fill="#656d76" font-size="16" font-weight="600" text-anchor="middle">KUBERNETES
            ARCHITECTURE</text>

          <!-- Control Plane -->
          <rect x="40" y="50" width="620" height="110" rx="8" fill="#f6f8fa" stroke="#d0d7de" stroke-width="1.5" />
          <text x="350" y="75" fill="#1a7f37" font-size="15" font-weight="700" text-anchor="middle">CONTROL PLANE</text>

          <!-- Components -->
          <rect x="70" y="90" width="100" height="50" rx="6" fill="#ddf4ff" stroke="#0969da" stroke-width="1.5" />
          <text x="120" y="120" fill="#1f2328" font-size="13" font-weight="600" text-anchor="middle">API Server</text>

          <rect x="200" y="90" width="80" height="50" rx="6" fill="#fff8c5" stroke="#9a6700" stroke-width="1.5" />
          <text x="240" y="120" fill="#1f2328" font-size="13" font-weight="600" text-anchor="middle">etcd</text>

          <rect x="310" y="90" width="90" height="50" rx="6" fill="#eaeef2" stroke="#d0d7de" />
          <text x="355" y="120" fill="#1f2328" font-size="13" font-weight="600" text-anchor="middle">Scheduler</text>

          <rect x="430" y="90" width="100" height="50" rx="6" fill="#eaeef2" stroke="#d0d7de" />
          <text x="480" y="115" fill="#1f2328" font-size="12" font-weight="600" text-anchor="middle">Controller</text>
          <text x="480" y="130" fill="#1f2328" font-size="12" font-weight="600" text-anchor="middle">Manager</text>

          <rect x="560" y="90" width="70" height="50" rx="6" fill="#eaeef2" stroke="#d0d7de" />
          <text x="595" y="115" fill="#1f2328" font-size="11" font-weight="600" text-anchor="middle">Cloud</text>
          <text x="595" y="130" fill="#1f2328" font-size="11" font-weight="600" text-anchor="middle">CM</text>

          <!-- Interaction Line (Only API talks to etcd) -->
          <line x1="170" y1="115" x2="200" y2="115" stroke="#0969da" stroke-width="2" marker-end="url(#arrow)" />

          <!-- Worker Nodes -->
          <rect x="40" y="190" width="280" height="100" rx="8" fill="#f6f8fa" stroke="#d0d7de" stroke-width="1.5" />
          <text x="180" y="215" fill="#1a7f37" font-size="14" font-weight="700" text-anchor="middle">WORKER NODE
            1</text>
          <rect x="60" y="230" width="70" height="40" rx="4" fill="#eaeef2" stroke="#d0d7de" />
          <text x="95" y="255" fill="#1f2328" font-size="12" font-weight="600" text-anchor="middle">Kubelet</text>
          <rect x="145" y="230" width="70" height="40" rx="4" fill="#eaeef2" stroke="#d0d7de" />
          <text x="180" y="255" fill="#1f2328" font-size="12" font-weight="600" text-anchor="middle">Proxy</text>
          <rect x="230" y="230" width="70" height="40" rx="4" fill="#eaeef2" stroke="#d0d7de" />
          <text x="265" y="255" fill="#1f2328" font-size="12" font-weight="600" text-anchor="middle">Pods</text>

          <rect x="340" y="190" width="280" height="100" rx="8" fill="#f6f8fa" stroke="#d0d7de" stroke-width="1.5" />
          <text x="480" y="215" fill="#1a7f37" font-size="14" font-weight="700" text-anchor="middle">WORKER NODE
            2</text>
          <rect x="360" y="230" width="70" height="40" rx="4" fill="#eaeef2" stroke="#d0d7de" />
          <text x="395" y="255" fill="#1f2328" font-size="12" font-weight="600" text-anchor="middle">Kubelet</text>

          <!-- Arrows -->
          <line x1="120" y1="140" x2="120" y2="170" stroke="#0969da" stroke-width="1.5" />
          <line x1="120" y1="170" x2="95" y2="230" stroke="#0969da" stroke-width="1.5" marker-end="url(#arrow)" />
          <line x1="120" y1="170" x2="395" y2="230" stroke="#0969da" stroke-width="1.5" marker-end="url(#arrow)" />
        </svg>
        <figcaption>Architecture: The API Server is the central hub. Kubelet manages the node. Kube-proxy manages
          networking.</figcaption>
      </figure>

      <h3>Workloads</h3>

      <h4>Pods</h4>
      <p>The smallest deployable object in Kubernetes. A Pod determines how to run a container.
        <br><em>Key Concept:</em> Containers in a pod share the <strong>same network namespace</strong> (IP address),
        storage volumes, and process namespace (sometimes).
        <br><em>Life:</em> Pods are <strong>ephemeral</strong>. They are born, they run, and they die. They are not
        resurrected; a new one is created to replace them.
      </p>

      <div class="snippet-label">Run a pod (imperative)</div>
      <pre><code>kubectl run nginx --image nginx
kubectl get pods -wide</code></pre>

      <h4>ReplicaSet</h4>
      <p>Ensures a specified number of pod replicas are running at any given time.
        <br><em>Selector:</em> Uses <code>selector</code> to match Pod labels. If a pod dies, RS starts a new one.
      </p>

      <h4>Deployments</h4>
      <p>The standard way to manage stateless applications. A Deployment manages ReplicaSets and provides declarative
        updates (Rolling Updates, Rollbacks).
        <br><em>Capabilities:</em> Scaling, pausing/resuming updates, rolling back to previous revisions.
      </p>

      <div class="snippet-label">Create Deployment</div>
      <pre><code>kubectl create deployment webapp --image=nginx --replicas=3
kubectl get deploy,rs,po</code></pre>

      <p>Scale: <code>kubectl scale --replicas=5 deployment/webapp</code> or edit via
        <code>kubectl edit deploy webapp</code>.
      </p>

      <h3>Imperative commands — exam speed reference</h3>
      <p>In the CKA exam, speed matters. Use imperative commands with <code>--dry-run=client -o yaml</code> to generate
        YAML quickly, then edit as needed.</p>
      <div class="snippet-label">Generate YAML templates fast</div>
      <pre><code># Pod
kubectl run nginx --image=nginx --dry-run=client -o yaml > pod.yaml

# Deployment
kubectl create deployment nginx --image=nginx --replicas=3 --dry-run=client -o yaml > deploy.yaml

# Service (ClusterIP)
kubectl expose pod redis --port=6379 --name redis-service --dry-run=client -o yaml

# Service (NodePort)
kubectl create service nodeport nginx --tcp=80:80 --node-port=30080 --dry-run=client -o yaml

# Job
kubectl create job my-job --image=busybox --dry-run=client -o yaml -- echo hello

# CronJob
kubectl create cronjob my-cron --image=busybox --schedule="*/5 * * * *" --dry-run=client -o yaml -- echo hi

# ConfigMap
kubectl create configmap app-config --from-literal=KEY=VALUE --dry-run=client -o yaml

# Secret
kubectl create secret generic app-secret --from-literal=PASSWORD=pass --dry-run=client -o yaml

# ServiceAccount
kubectl create serviceaccount my-sa --dry-run=client -o yaml

# Namespace
kubectl create namespace dev

# Role & RoleBinding
kubectl create role pod-reader --verb=get,list --resource=pods -n dev
kubectl create rolebinding dev-read --role=pod-reader --user=jane -n dev

# ClusterRole & ClusterRoleBinding
kubectl create clusterrole node-reader --verb=get,list --resource=nodes
kubectl create clusterrolebinding node-read --clusterrole=node-reader --user=jane

# Ingress
kubectl create ingress my-ingress --rule="host/path=svc:80" --dry-run=client -o yaml</code></pre>
      <div class="snippet-label">Quick edit and apply pattern</div>
      <pre><code># Generate → Edit → Apply
kubectl run mypod --image=nginx --dry-run=client -o yaml > mypod.yaml
vi mypod.yaml   # add labels, resources, volumes, etc.
kubectl apply -f mypod.yaml

# Edit running resource
kubectl edit deployment nginx

# Replace (force update)
kubectl replace --force -f pod.yaml</code></pre>

      <h3>Namespaces</h3>
      <p>Objects live in a namespace (default is <code>default</code>). List pods in a namespace:
        <code>kubectl get pods --namespace=kube-system</code> or <code>-n kube-system</code>. Create in a namespace:
        <code>kubectl create -f pod-definition.yaml --namespace=dev</code>. Add <code>namespace: dev</code> under
        <code>metadata</code> in the YAML to fix the namespace.
      </p>
      <div class="snippet-label">Create namespace</div>
      <pre><code>apiVersion: v1
kind: Namespace
metadata:
  name: dev</code></pre>
      <pre><code>kubectl create -f namespace-dev.yaml
# or
kubectl create namespace dev</code></pre>
      <p>Switch default namespace:
        <code>kubectl config set-context $(kubectl config current-context) --namespace=dev</code>. All namespaces:
        <code>kubectl get pods --all-namespaces</code>.
      </p>
      <div class="snippet-label">ResourceQuota (limit resources in a namespace)</div>
      <pre><code>apiVersion: v1
kind: ResourceQuota
metadata:
  name: compute-quota
  namespace: dev
spec:
  hard:
    pods: "10"
    requests.cpu: "4"
    requests.memory: 5Gi
    limits.cpu: "10"
    limits.memory: 10Gi</code></pre>
      <pre><code>kubectl create -f compute-quota.yaml</code></pre>

      <h3>Services</h3>
      <p>Three types: <strong>NodePort</strong> (expose on node port), <strong>ClusterIP</strong> (virtual IP inside
        cluster), <strong>LoadBalancer</strong> (cloud load balancer).</p>
      <div class="snippet-label">NodePort service</div>
      <pre><code>apiVersion: v1
kind: Service
metadata:
  name: myapp-service
spec:
  type: NodePort
  ports:
  - targetPort: 80
    port: 80
    nodePort: 30008
  selector:
    app: myapp
    type: front-end</code></pre>
      <div class="snippet-label">ClusterIP service</div>
      <pre><code>apiVersion: v1
kind: Service
metadata:
  name: back-end
spec:
  type: ClusterIP
  ports:
  - targetPort: 80
    port: 80
  selector:
    app: myapp
    type: back-end</code></pre>
      <pre><code>kubectl create -f service-definition.yaml
kubectl get services
curl http://&lt;node-ip&gt;:30008   # for NodePort</code></pre>
      <figure class="diagram">
        <svg viewBox="0 0 540 160" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">
          <rect x="20" y="20" width="155" height="120" rx="8" fill="#eaeef2" stroke="#d0d7de" />
          <text x="97" y="46" fill="#1a7f37" font-size="16" font-weight="600" text-anchor="middle">NodePort</text>
          <text x="97" y="66" fill="#656d76" font-size="13" text-anchor="middle">Node:30008 → :80</text>
          <text x="97" y="82" fill="#656d76" font-size="13" text-anchor="middle">→ Pod targetPort</text>
          <text x="97" y="106" fill="#1f2328" font-size="13" text-anchor="middle">External via</text>
          <text x="97" y="120" fill="#1f2328" font-size="13" text-anchor="middle">any node + nodePort</text>
          <rect x="192" y="20" width="155" height="120" rx="8" fill="#eaeef2" stroke="#d0d7de" />
          <text x="269" y="46" fill="#1a7f37" font-size="16" font-weight="600" text-anchor="middle">ClusterIP</text>
          <text x="269" y="66" fill="#656d76" font-size="13" text-anchor="middle">Virtual IP 10.96.x.x</text>
          <text x="269" y="82" fill="#656d76" font-size="13" text-anchor="middle">Cluster-internal</text>
          <text x="269" y="106" fill="#1f2328" font-size="13" text-anchor="middle">Frontend → Backend</text>
          <text x="269" y="120" fill="#1f2328" font-size="12" text-anchor="middle">svc.ns.svc.cluster.local</text>
          <rect x="364" y="20" width="155" height="120" rx="8" fill="#eaeef2" stroke="#d0d7de" />
          <text x="441" y="46" fill="#1a7f37" font-size="16" font-weight="600" text-anchor="middle">LoadBalancer</text>
          <text x="441" y="66" fill="#656d76" font-size="13" text-anchor="middle">Cloud LB → NodePort</text>
          <text x="441" y="82" fill="#656d76" font-size="13" text-anchor="middle">→ Service → Pods</text>
          <text x="441" y="106" fill="#1f2328" font-size="13" text-anchor="middle">External IP</text>
          <text x="441" y="120" fill="#1f2328" font-size="13" text-anchor="middle">(AWS/GCP/Azure)</text>
        </svg>
        <figcaption>Service types: NodePort (expose on node port), ClusterIP (internal VIP), LoadBalancer (cloud LB).
        </figcaption>
      </figure>

      <!-- 03 Scheduling -->
      <h2 id="section-03">03 — Scheduling</h2>
      <h3>How scheduling works</h3>
      <p>The scheduler watches for pods with no <code>nodeName</code>. It picks a node (filtering + scoring), then
        either sets <code>spec.nodeName</code> or creates a <strong>Binding</strong> object. The
        <strong>kubelet</strong> on that node then creates the pod. Without a scheduler, you can set
        <code>nodeName</code> yourself to force a node.
      </p>
      <figure class="diagram">
        <svg viewBox="0 0 480 100" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">
          <rect x="24" y="24" width="88" height="52" rx="6" fill="#eaeef2" stroke="#0969da" />
          <text x="68" y="52" fill="#1f2328" font-size="14" text-anchor="middle">Pod created</text>
          <path d="M112 50 L136 50" stroke="#1a7f37" stroke-width="2" />
          <rect x="136" y="24" width="88" height="52" rx="6" fill="#eaeef2" stroke="#0969da" />
          <text x="180" y="50" fill="#1f2328" font-size="14" text-anchor="middle">Scheduler</text>
          <text x="180" y="66" fill="#656d76" font-size="12" text-anchor="middle">picks node</text>
          <path d="M224 50 L248 50" stroke="#1a7f37" stroke-width="2" />
          <rect x="248" y="24" width="88" height="52" rx="6" fill="#eaeef2" stroke="#0969da" />
          <text x="292" y="52" fill="#1f2328" font-size="14" text-anchor="middle">nodeName set</text>
          <path d="M336 50 L360 50" stroke="#1a7f37" stroke-width="2" />
          <rect x="360" y="24" width="88" height="52" rx="6" fill="#eaeef2" stroke="#1a7f37" />
          <text x="404" y="50" fill="#1f2328" font-size="14" text-anchor="middle">Kubelet</text>
          <text x="404" y="66" fill="#656d76" font-size="12" text-anchor="middle">runs pod</text>
        </svg>
        <figcaption>Pod scheduling flow: scheduler assigns node, kubelet runs the pod.</figcaption>
      </figure>
      <h4>Manual scheduling (no scheduler or override)</h4>
      <p>Set <code>nodeName</code> in the pod spec to pin a pod to a specific node. Kubernetes will not change it.</p>
      <pre><code>apiVersion: v1
kind: Pod
metadata:
  name: nginx
  labels:
    name: nginx
spec:
  containers:
  - name: nginx
    image: nginx
    ports:
    - containerPort: 8080
  nodeName: node02</code></pre>
      <p>Alternatively create a <strong>Binding</strong> object (target = node) and POST it to
        <code>/api/v1/namespaces/&lt;ns&gt;/pods/&lt;name&gt;/binding</code>; the pod spec stays without nodeName until
        the binding is processed.
      </p>

      <h3>Labels and selectors</h3>
      <p>Labels are key-value pairs on objects. Selectors filter by labels. Services and ReplicaSets use selectors to
        target pods.</p>
      <div class="snippet-label">Pod with labels</div>
      <pre><code>apiVersion: v1
kind: Pod
metadata:
  name: simple-webapp
  labels:
    app: App1
    function: Front-end
spec:
  containers:
  - name: simple-webapp
    image: simple-webapp
    ports:
    - containerPort: 8080</code></pre>
      <pre><code>kubectl get pods --selector app=App1</code></pre>
      <p>Annotations (e.g. <code>buildversion: 1.34</code>) go under <code>metadata.annotations</code> for
        non-identifying info.</p>

      <h3>Taints and tolerations</h3>
      <p>Taints restrict which pods can be scheduled on a node. Only pods with matching tolerations can run there.
        Effects: <code>NoSchedule</code>, <code>PreferNoSchedule</code>, <code>NoExecute</code>.</p>
      <pre><code>kubectl taint nodes node1 app=blue:NoSchedule</code></pre>
      <div class="snippet-label">Pod with toleration</div>
      <pre><code>apiVersion: v1
kind: Pod
metadata:
  name: myapp-pod
spec:
  containers:
  - name: nginx-container
    image: nginx
  tolerations:
  - key: "app"
    operator: "Equal"
    value: "blue"
    effect: "NoSchedule"</code></pre>
      <pre><code>kubectl describe node kubemaster | grep Taint</code></pre>

      <h3>Taints and Tolerations</h3>
      <p>A mechanism to <strong>restrict</strong> what pods can be placed on what nodes. Taints are set on
        <strong>Nodes</strong> (to repel pods). Tolerations are set on <strong>Pods</strong> (to tolerate the
        repulsion).
      </p>
      <ul>
        <li><strong>Effect - NoSchedule:</strong> Pod will not be scheduled on the node.</li>
        <li><strong>Effect - PreferNoSchedule:</strong> System will try to avoid placing the pod on the node, but it's
          not guaranteed.</li>
        <li><strong>Effect - NoExecute:</strong> New pods won't be scheduled, and <em>existing</em> pods on the node
          will be evicted if they don't tolerate the taint.</li>
      </ul>
      <pre><code>kubectl taint nodes node1 gpu=true:NoSchedule       # Apply Taint
kubectl describe node node1 | grep Taint             # Check Taint
kubectl taint nodes node1 gpu=true:NoSchedule-      # Remove Taint</code></pre>

      <div class="snippet-label">Pod Toleration</div>
      <pre><code>spec:
  tolerations:
  - key: "gpu"
    operator: "Equal"
    value: "true"
    effect: "NoSchedule"</code></pre>

      <h3>Node Affinity</h3>
      <p>Allows you to constrain which nodes your pod is eligible to be scheduled on, based on labels on the node.
        Conceptually similar to <code>nodeSelector</code> but more expressive.</p>
      <ul>
        <li><strong>requiredDuringSchedulingIgnoredDuringExecution:</strong> Hard rule. Must match.</li>
        <li><strong>preferredDuringSchedulingIgnoredDuringExecution:</strong> Soft rule. Will try to match, but can
          schedule elsewhere if needed.</li>
      </ul>

      <h3>Static Pods</h3>
      <p>Pods managed <strong>directly by the kubelet</strong> on a specific node, without the API server observing
        them. The kubelet watches a directory (usually <code>/etc/kubernetes/manifests</code>) and creates pods from
        files there.
        <br><em>Use Case:</em> Bootstrapping the control plane components (etcd, apiserver) itself.
      </p>

      <h3>Resource Requirements</h3>
      <p><strong>Requests:</strong> The amount of CPU/Memory guaranteed to a container. The Scheduler uses this to find
        a node.
        <br><strong>Limits:</strong> The maximum amount a container can use. If it exceeds memory limit ->
        <strong>OOMKilled</strong>. If it exceeds CPU limit -> <strong>Throttled</strong>.
      </p>

      <h3>DaemonSets</h3>
      <p>Ensures that <strong>one copy</strong> of a Pod runs on <strong>all</strong> (or a subset of) nodes.
        <br><em>Use Case:</em> Cluster storage daemons (glusterd), log collectors (fluentd), node monitoring
        (node-exporter).
      </p>
      <pre><code>apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: monitoring-daemon
  labels:
    app: nginx
spec:
  selector:
    matchLabels:
      app: monitoring-agent
  template:
    metadata:
      labels:
        app: monitoring-agent
    spec:
      containers:
      - name: monitoring-agent
        image: monitoring-agent</code></pre>
      <pre><code>kubectl create -f daemon-set-definition.yaml
kubectl get daemonsets
kubectl describe daemonsets monitoring-daemon</code></pre>

      <h3>Node affinity</h3>
      <p>Like nodeSelector but with expressive rules. Types: <code>requiredDuringSchedulingIgnoredDuringExecution</code>
        (hard requirement), <code>preferredDuringSchedulingIgnoredDuringExecution</code> (soft). Use
        <code>matchExpressions</code> with operators <code>In</code>, <code>NotIn</code>, <code>Exists</code>,
        <code>DoesNotExist</code>.
      </p>
      <pre><code>spec:
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
        - matchExpressions:
          - key: size
            operator: In
            values: [Large, Medium]
      # preferredDuringSchedulingIgnoredDuringExecution for soft preference</code></pre>

      <h3>Multiple schedulers</h3>
      <p>You can run a custom scheduler (e.g. <code>my-custom-scheduler</code>) alongside the default. In the pod spec
        set <code>schedulerName: my-custom-scheduler</code>. Only that scheduler will assign that pod. View events:
        <code>kubectl get events</code>.
      </p>

      <h3>Static pods</h3>
      <p>Kubelet can run pods from a directory on the host (no API server). Configure kubelet with
        <code>--pod-manifest-path</code> or in config as <code>staticPodPath</code>. Kubelet creates both static pods
        and API-server pods. Static pods are mirrored in the API as read-only.
      </p>

      <!-- 04 Logging & Monitoring -->
      <h2 id="section-04">04 — Logging and Monitoring</h2>
      <h3>Application logs</h3>
      <p>Container stdout/stderr are captured by kubelet and exposed via the API. Use <code>kubectl logs</code>. For a
        <strong>multi-container</strong> pod you must specify the container name.
      </p>
      <pre><code>kubectl logs -f &lt;pod-name&gt;
kubectl logs -f &lt;pod-name&gt; &lt;container-name&gt;
kubectl logs &lt;pod-name&gt; --previous
kubectl logs &lt;pod-name&gt; -f --previous</code></pre>
      <p><code>-f</code> streams logs; <code>--previous</code> shows logs from the <strong>previous</strong> container
        instance (e.g. after a crash/restart).</p>
      <h3>Cluster metrics</h3>
      <p><strong>Metrics Server</strong> provides resource metrics (CPU/memory) for <code>kubectl top nodes</code> and
        <code>kubectl top pods</code>. It is not for long-term storage; use a monitoring stack (Prometheus, etc.) for
        that. Legacy Heapster is deprecated.
      </p>

      <!-- 05 Application Lifecycle -->
      <h2 id="section-05">05 — Application Lifecycle Management</h2>
      <h3>Rolling updates and rollback</h3>
      <p>Deployment strategies: <strong>Recreate</strong> (all down then up), <strong>RollingUpdate</strong> (default).
      </p>
      <pre><code>kubectl rollout status deployment/myapp-deployment
kubectl rollout history deployment/myapp-deployment
kubectl set image deployment/myapp-deployment nginx=nginx:1.9.1
kubectl apply -f deployment-definition.yaml
kubectl rollout undo deployment/myapp-deployment</code></pre>

      <h3>ConfigMaps</h3>
      <p>Create: imperative
        <code>kubectl create configmap app-config --from-literal=APP_COLOR=blue --from-literal=APP_MODE=prod</code> or
        from file <code>--from-file=app_config.properties</code>.
      </p>
      <div class="snippet-label">ConfigMap YAML</div>
      <pre><code>apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  APP_COLOR: blue
  APP_MODE: prod</code></pre>
      <pre><code>kubectl create -f config-map.yaml
kubectl get configmaps
kubectl get cm
kubectl describe configmaps app-config</code></pre>
      <div class="snippet-label">Inject ConfigMap into pod (envFrom)</div>
      <pre><code>apiVersion: v1
kind: Pod
metadata:
  name: simple-webapp-color
spec:
  containers:
  - name: simple-webapp-color
    image: simple-webapp-color
    ports:
    - containerPort: 8080
    envFrom:
    - configMapRef:
        name: app-config</code></pre>

      <h3>Secrets</h3>
      <p>Store sensitive data (base64 in YAML). Create:
        <code>kubectl create secret generic app-secret --from-literal=DB_Host=mysql --from-literal=DB_User=root --from-literal=DB_Password=paswrd</code>.
        Encode for YAML: <code>echo -n "paswrd" | base64</code>.
      </p>
      <pre><code>apiVersion: v1
kind: Secret
metadata:
  name: app-secret
data:
  DB_Host: bX1zcWw=
  DB_User: cm9vdA==
  DB_Password: cGFzd3Jk</code></pre>
      <pre><code>kubectl create -f secret-data.yaml
kubectl get secrets
kubectl describe secret app-secret
kubectl get secret app-secret -o yaml</code></pre>
      <p>Decode: <code>echo -n "bX1zcWw=" | base64 --decode</code>. Inject into pod with
        <code>envFrom: - secretRef: name: app-secret</code> (same structure as configMapRef).
      </p>

      <h3>Commands and arguments</h3>
      <p>Override image <strong>CMD</strong> with <code>command</code> (args to entrypoint) and
        <strong>ENTRYPOINT</strong> with <code>args</code> in the container spec. In Kubernetes, <code>command</code>
        corresponds to Docker ENTRYPOINT and <code>args</code> to CMD. Example: <code>command: ["sleep"]</code>,
        <code>args: ["3600"]</code>.
      </p>
      <div class="snippet-label">Docker → Kubernetes mapping</div>
      <pre><code># Dockerfile          → Pod spec
# ENTRYPOINT ["python"] → command: ["python"]
# CMD ["app.py"]       → args: ["app.py"]

apiVersion: v1
kind: Pod
metadata:
  name: command-demo
spec:
  containers:
  - name: demo
    image: ubuntu
    command: ["sleep"]    # overrides ENTRYPOINT
    args: ["5000"]        # overrides CMD</code></pre>
      <h3>Environment variables</h3>
      <p>Set env vars directly, from ConfigMaps, or from Secrets. Three injection methods:</p>
      <pre><code>containers:
- name: app
  image: myapp
  env:
  # 1. Plain key-value
  - name: APP_COLOR
    value: pink
  # 2. From ConfigMap key
  - name: APP_ENV
    valueFrom:
      configMapKeyRef:
        name: app-config
        key: APP_ENV
  # 3. From Secret key
  - name: DB_PASSWORD
    valueFrom:
      secretKeyRef:
        name: app-secret
        key: DB_Password</code></pre>

      <h3>Multi-container pod design patterns</h3>
      <p>CKA tests multi-container pods. Three main patterns:</p>
      <ul>
        <li><strong>Sidecar:</strong> auxiliary container that enhances the main container (e.g. log shipper that reads
          shared volume, Istio proxy).</li>
        <li><strong>Ambassador:</strong> proxy container that handles connections to external services on behalf of the
          main container (e.g. localhost proxy to reach different DB environments).</li>
        <li><strong>Adapter:</strong> transforms data from the main container before exporting it (e.g. log format
          normaliser, metrics adapter).</li>
      </ul>
      <div class="snippet-label">Sidecar example (log streamer)</div>
      <pre><code>apiVersion: v1
kind: Pod
metadata:
  name: app-with-sidecar
spec:
  containers:
  - name: app
    image: busybox
    command: ['sh', '-c', 'while true; do echo "$(date) INFO app running" >> /var/log/app.log; sleep 5; done']
    volumeMounts:
    - name: log-volume
      mountPath: /var/log
  - name: sidecar
    image: busybox
    command: ['sh', '-c', 'tail -f /var/log/app.log']
    volumeMounts:
    - name: log-volume
      mountPath: /var/log
  volumes:
  - name: log-volume
    emptyDir: {}</code></pre>
      <h3>Init containers</h3>
      <p>Run to completion before main containers start. Use for one-time setup or waiting for dependencies. If an init
        container fails, the pod is restarted (all init containers re-run). Order: initContainers run sequentially; then
        main containers start.</p>
      <pre><code>apiVersion: v1
kind: Pod
metadata:
  name: myapp-pod
  labels:
    app: myapp
spec:
  containers:
  - name: myapp-container
    image: busybox:1.28
    command: ['sh', '-c', 'echo The app is running! && sleep 3600']
  initContainers:
  - name: init-myservice
    image: busybox:1.28
    command: ['sh', '-c', 'until nslookup myservice; do echo waiting for myservice; sleep 2; done;']
  - name: init-mydb
    image: busybox:1.28
    command: ['sh', '-c', 'until nslookup mydb; do echo waiting for mydb; sleep 2; done;']</code></pre>

      <h3>Liveness and readiness probes</h3>
      <p>Probes make deployments <strong>self-healing</strong>. <strong>livenessProbe</strong>: if it fails, the
        container is restarted. <strong>readinessProbe</strong>: if it fails, the pod is removed from Service endpoints
        (no traffic until ready). Types: <code>httpGet</code> (HTTP path), <code>exec</code> (command),
        <code>tcpSocket</code> (port open).
      </p>
      <div class="snippet-label">Probes example</div>
      <pre><code>containers:
- name: app
  image: myapp:1.0
  livenessProbe:
    httpGet:
      path: /healthz
      port: 8080
    initialDelaySeconds: 15
    periodSeconds: 20
  readinessProbe:
    httpGet:
      path: /ready
      port: 8080
    initialDelaySeconds: 5
    periodSeconds: 10</code></pre>

      <h3>HorizontalPodAutoscaler (HPA)</h3>
      <p><strong>Workload autoscaling</strong>: HPA scales a Deployment/ReplicaSet based on CPU (or custom metrics).
        Requires <strong>Metrics Server</strong> in the cluster for <code>kubectl top</code> and CPU-based scaling. Set
        <code>resources.requests</code> on the deployment so HPA can compute utilization.
      </p>
      <div class="snippet-label">HPA YAML</div>
      <pre><code>apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: myapp-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: myapp-deployment
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 80</code></pre>
      <pre><code>kubectl autoscale deployment myapp-deployment --min=2 --max=10 --cpu-percent=80
kubectl get hpa
kubectl describe hpa myapp-hpa</code></pre>

      <!-- 06 Cluster Maintenance -->
      <h2 id="section-06">06 — Cluster Maintenance</h2>
      <h3>OS upgrades and node maintenance</h3>
      <p><strong>Important:</strong> If a node is down for <strong>more than 5 minutes</strong>, the control plane may
        terminate pods that were on that node (they will be recreated elsewhere if managed by a controller).</p>
      <ul>
        <li><strong>kubectl drain &lt;node&gt;</strong>: Evicts workloads from the node (pods are rescheduled elsewhere)
          and marks the node <strong>unschedulable</strong> (cordon). Use before OS upgrade or maintenance.</li>
        <li><strong>kubectl uncordon &lt;node&gt;</strong>: Marks the node schedulable again after it is back.</li>
        <li><strong>kubectl cordon &lt;node&gt;</strong>: Only marks the node unschedulable; does <strong>not</strong>
          evict existing pods.</li>
      </ul>
      <figure class="diagram">
        <svg viewBox="0 0 420 120" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">
          <rect x="20" y="20" width="118" height="80" rx="8" fill="#eaeef2" stroke="#d0d7de" />
          <text x="79" y="48" fill="#1a7f37" font-size="15" font-weight="600" text-anchor="middle">cordon</text>
          <text x="79" y="68" fill="#656d76" font-size="13" text-anchor="middle">No new pods</text>
          <text x="79" y="84" fill="#656d76" font-size="13" text-anchor="middle">Pods stay</text>
          <rect x="151" y="20" width="118" height="80" rx="8" fill="#eaeef2" stroke="#d0d7de" />
          <text x="210" y="48" fill="#0969da" font-size="15" font-weight="600" text-anchor="middle">drain</text>
          <text x="210" y="68" fill="#656d76" font-size="13" text-anchor="middle">Cordon + evict</text>
          <text x="210" y="84" fill="#656d76" font-size="13" text-anchor="middle">Pods move away</text>
          <rect x="282" y="20" width="118" height="80" rx="8" fill="#eaeef2" stroke="#d0d7de" />
          <text x="341" y="48" fill="#1a7f37" font-size="15" font-weight="600" text-anchor="middle">uncordon</text>
          <text x="341" y="68" fill="#656d76" font-size="13" text-anchor="middle">Allow scheduling</text>
          <text x="341" y="84" fill="#656d76" font-size="13" text-anchor="middle">again</text>
        </svg>
        <figcaption>cordon = no new pods; drain = cordon + evict; uncordon = allow scheduling again.</figcaption>
      </figure>

      <h3>Kubernetes versions</h3>
      <p>Kubernetes supports the last 3 minor versions. Upgrade one minor version at a time. kubeadm, kubelet, and
        control-plane components can be at different versions during upgrade.</p>

      <h3>Cluster upgrade (kubeadm)</h3>
      <p><strong>Master:</strong></p>
      <pre><code>kubeadm upgrade plan
apt-get upgrade -y kubeadm=1.12.0-00
kubeadm upgrade apply v1.12.0
apt-get upgrade kubelet=1.12.0-00
systemctl restart kubelet
kubectl get nodes</code></pre>
      <p><strong>Workers:</strong> drain, upgrade kubeadm and kubelet, update node config, restart kubelet, uncordon.
      </p>
      <pre><code>kubectl drain node-1
apt-get upgrade -y kubeadm=1.12.0-00 kubelet=1.12.0-00
kubeadm upgrade node config --kubelet-version v1.12.0
systemctl restart kubelet
kubectl uncordon node-1</code></pre>

      <h3>Backup and restore</h3>
      <p><strong>Resource configs:</strong> store YAML in Git; or
        <code>kubectl get all --all-namespaces -o yaml &gt; all-deploy-services.yaml</code> (partial). Tools like Velero
        can backup/restore resources.
      </p>
      <p><strong>ETCD snapshot:</strong></p>
      <pre><code>ETCDCTL_API=3 etcdctl snapshot save snapshot.db
ETCDCTL_API=3 etcdctl snapshot status snapshot.db</code></pre>
      <p>With kubeadm, etcd runs as a pod; use the correct endpoint and certs. Example (adjust paths/endpoints for your
        setup):</p>
      <pre><code>ETCDCTL_API=3 etcdctl snapshot save snapshot.db \
  --endpoints=https://127.0.0.1:2379 \
  --cacert=/etc/kubernetes/pki/etcd/ca.crt \
  --cert=/etc/kubernetes/pki/etcd/server.crt \
  --key=/etc/kubernetes/pki/etcd/server.key</code></pre>
      <p>Restore: <code>etcdctl snapshot restore snapshot.db --data-dir=/var/lib/etcd-from-backup</code>, then point
        etcd to the new data-dir and restart control-plane components.</p>

      <h3>PodDisruptionBudget (PDB)</h3>
      <p>PDB limits voluntary disruptions (e.g. <code>kubectl drain</code>, node upgrades) so that a minimum number of
        pods stay available. <strong>minAvailable</strong>: at least N pods (number or percentage).
        <strong>maxUnavailable</strong>: at most N pods down (number or percentage). Drain respects PDBs and may block
        until pods can be rescheduled.
      </p>
      <div class="snippet-label">PDB example (minAvailable)</div>
      <pre><code>apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: myapp-pdb
spec:
  minAvailable: 2
  selector:
    matchLabels:
      app: myapp</code></pre>
      <div class="snippet-label">PDB with maxUnavailable</div>
      <pre><code>spec:
  maxUnavailable: 1
  selector:
    matchLabels:
      app: myapp</code></pre>
      <pre><code>kubectl get pdb
kubectl describe pdb myapp-pdb</code></pre>

      <!-- 07 Security -->
      <h2 id="section-07">07 — Security</h2>

      <h3>Kubernetes security primitives</h3>
      <p>Security starts with the <strong>API server</strong> — it is the gatekeeper. Two key questions: <strong>who can
          access?</strong> (authentication) and <strong>what can they do?</strong> (authorization). All access goes
        through the API server, making it the single chokepoint for security.</p>

      <h3>Authentication</h3>
      <p>Kubernetes does <strong>not</strong> manage user accounts natively (no User object). It relies on external
        mechanisms. Two types of accounts:</p>
      <ul>
        <li><strong>Users</strong> (humans): admins, developers — managed externally (certificates, LDAP, OIDC tokens).
        </li>
        <li><strong>Service Accounts</strong> (machines): used by pods and processes — managed by Kubernetes.</li>
      </ul>
      <p>Authentication methods: <strong>static password/token files</strong> (deprecated),
        <strong>certificates</strong> (most common with kubeadm), <strong>OIDC</strong>, <strong>webhook</strong>. All
        requests are authenticated by the API server before authorization.
      </p>

      <h3>Service Accounts</h3>
      <p>ServiceAccounts are namespace-scoped. Every namespace has a <code>default</code> SA. Pods automatically mount
        the SA token. Use custom SAs to give pods specific RBAC permissions.</p>
      <pre><code># Create
kubectl create serviceaccount dashboard-sa
kubectl get serviceaccount

# Use in pod
apiVersion: v1
kind: Pod
metadata:
  name: my-dashboard
spec:
  serviceAccountName: dashboard-sa
  automountServiceAccountToken: false   # opt-out of auto-mount
  containers:
  - name: dashboard
    image: my-dashboard:v1</code></pre>
      <p>Since Kubernetes 1.24, ServiceAccount tokens are no longer auto-created as Secrets. Use
        <code>kubectl create token &lt;sa-name&gt;</code> for short-lived tokens, or create a Secret with annotation
        <code>kubernetes.io/service-account.name</code>.
      </p>

      <h3>TLS in Kubernetes</h3>
      <p>Cluster components use <strong>TLS</strong>: servers use <strong>server certificates</strong>, clients use
        <strong>client certificates</strong> for authentication. API server, etcd, kubelet, and other control-plane
        components each have certs (typically under <code>/etc/kubernetes/pki/</code> on kubeadm). Certificate API can
        issue signed certs for users; the controller manager handles signing.
      </p>
      <h4>Key certificate files (kubeadm)</h4>
      <ul>
        <li><code>ca.crt / ca.key</code> — Cluster CA (root of trust)</li>
        <li><code>apiserver.crt / apiserver.key</code> — API server TLS</li>
        <li><code>apiserver-kubelet-client.crt</code> — API → kubelet client cert</li>
        <li><code>apiserver-etcd-client.crt</code> — API → etcd client cert</li>
        <li><code>etcd/ca.crt, etcd/server.crt</code> — etcd TLS</li>
        <li><code>front-proxy-ca.crt</code> — Aggregation layer</li>
      </ul>

      <h3>Viewing certificates</h3>
      <pre><code>openssl x509 -in /etc/kubernetes/pki/apiserver.crt -text -noout</code></pre>
      <p>Check subject, issuer, validity (not after), SANs (Subject Alternative Names). Same for other certs in
        <code>/etc/kubernetes/pki/</code> (ca.crt, apiserver-kubelet-client.crt, etc.).
      </p>

      <h3>Certificate API — CSR workflow</h3>
      <p>Kubernetes has a built-in <strong>Certificate Signing Request (CSR)</strong> API for issuing client
        certificates. The controller manager signs the certificates using the cluster CA.</p>
      <div class="snippet-label">Create and approve a user certificate</div>
      <pre><code># 1. User generates key and CSR
openssl genrsa -out jane.key 2048
openssl req -new -key jane.key -subj "/CN=jane" -out jane.csr

# 2. Admin creates CSR object (base64-encode the CSR)
cat jane.csr | base64 | tr -d '\n'</code></pre>
      <pre><code># 3. CSR YAML
apiVersion: certificates.k8s.io/v1
kind: CertificateSigningRequest
metadata:
  name: jane
spec:
  request: &lt;base64-encoded-csr&gt;
  signerName: kubernetes.io/kube-apiserver-client
  usages:
  - client auth</code></pre>
      <pre><code># 4. Approve and extract certificate
kubectl create -f jane-csr.yaml
kubectl get csr
kubectl certificate approve jane
kubectl get csr jane -o jsonpath='{.status.certificate}' | base64 --decode > jane.crt

# 5. Deny a CSR
kubectl certificate deny bad-user</code></pre>
      <h3>kubeconfig</h3>
      <p>kubeconfig holds clusters (API server URL, CA), users (credentials: cert/key or token), and
        <strong>contexts</strong> (which cluster + which user + optional namespace). Default file:
        <code>~/.kube/config</code>.
      </p>
      <pre><code>kubectl config view
kubectl config view --kubeconfig=my-custom-config
kubectl config use-context &lt;context-name&gt;
kubectl config current-context
kubectl get pods --kubeconfig config</code></pre>
      <p>To set default namespace for current context:
        <code>kubectl config set-context $(kubectl config current-context) --namespace=dev</code>.
      </p>
      <h3>RBAC — Role and RoleBinding</h3>
      <p>Role: apiGroups, resources, verbs. RoleBinding: links subject (user/group/serviceaccount) to Role. Both are
        namespace-scoped.</p>
      <pre><code>apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: developer
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list", "update", "delete", "create"]
- apiGroups: [""]
  resources: ["configmaps"]
  verbs: ["create"]</code></pre>
      <pre><code>apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: devuser-developer-binding
subjects:
- kind: User
  name: dev-user
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: Role
  name: developer
  apiGroup: rbac.authorization.k8s.io</code></pre>
      <pre><code>kubectl create -f developer-role.yaml
kubectl create -f devuser-developer-binding.yaml
kubectl get roles
kubectl get rolebindings
kubectl describe role developer
kubectl describe rolebinding devuser-developer-binding
kubectl auth can-i create pods --as=dev-user -n default</code></pre>

      <h3>ClusterRole and ClusterRoleBinding</h3>
      <p>ClusterRole can define access to cluster-scoped resources (e.g. nodes) or to namespaced resources across all
        namespaces.</p>
      <pre><code>apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: cluster-administrator
rules:
- apiGroups: [""]
  resources: ["nodes"]
  verbs: ["get", "list", "delete", "create"]</code></pre>
      <pre><code>apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: cluster-admin-role-binding
subjects:
- kind: User
  name: cluster-admin
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: cluster-administrator
  apiGroup: rbac.authorization.k8s.io</code></pre>
      <pre><code>kubectl create -f cluster-admin-role.yaml
kubectl create -f cluster-admin-role-binding.yaml
kubectl api-resources --namespaced=true
kubectl api-resources --namespaced=false</code></pre>

      <h3>Network policy</h3>
      <p>Controls ingress/egress to pods by selector. Default: no restrictions. Once a NetworkPolicy selects a pod, that
        pod denies traffic not allowed by any policy.</p>
      <pre><code>apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: db-policy
spec:
  podSelector:
    matchLabels:
      role: db
  policyTypes:
  - Ingress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          role: api-pod
    ports:
    - protocol: TCP
      port: 3306</code></pre>
      <pre><code>kubectl create -f policy-definition.yaml</code></pre>
      <h3>Image security</h3>
      <p>Default image registry is <strong>docker.io</strong>. Image <code>nginx</code> is really
        <code>docker.io/library/nginx</code>. For private registries, create a <code>docker-registry</code> secret and
        reference it in the pod spec.
      </p>
      <div class="snippet-label">Pull from private registry</div>
      <pre><code># Create registry secret
kubectl create secret docker-registry regcred \
  --docker-server=private-registry.io \
  --docker-username=registry-user \
  --docker-password=registry-password \
  --docker-email=registry-user@org.com</code></pre>
      <pre><code># Use in pod
apiVersion: v1
kind: Pod
metadata:
  name: private-app
spec:
  containers:
  - name: app
    image: private-registry.io/apps/internal-app
  imagePullSecrets:
  - name: regcred</code></pre>

      <h3>Security context</h3>
      <p>Restrict pod/container behavior: run as non-root user, read-only root filesystem, drop capabilities. Set at
        <code>spec.securityContext</code> (pod) or <code>spec.containers[].securityContext</code> (container).
        Container-level settings override pod-level. Capabilities can only be set at <strong>container</strong> level.
      </p>
      <pre><code>spec:
  securityContext:
    runAsUser: 1000
    runAsGroup: 3000
    fsGroup: 2000
  containers:
  - name: ubuntu
    image: ubuntu
    securityContext:
      runAsUser: 1000
      runAsNonRoot: true
      readOnlyRootFilesystem: true
      capabilities:
        add: ["NET_ADMIN", "SYS_TIME"]
        drop: ["ALL"]</code></pre>
      <pre><code># Check who's running inside the container
kubectl exec my-pod -- whoami
kubectl exec my-pod -- id</code></pre>
      <figure class="diagram">
        <svg viewBox="0 0 400 110" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">
          <rect x="24" y="24" width="100" height="62" rx="6" fill="#eaeef2" stroke="#0969da" />
          <text x="74" y="48" fill="#1f2328" font-size="14" font-weight="600" text-anchor="middle">Role</text>
          <text x="74" y="64" fill="#656d76" font-size="12" text-anchor="middle">apiGroups, resources</text>
          <text x="74" y="78" fill="#656d76" font-size="12" text-anchor="middle">verbs</text>
          <path d="M124 55 L148 55" stroke="#1a7f37" stroke-width="2" />
          <rect x="148" y="24" width="104" height="62" rx="6" fill="#eaeef2" stroke="#0969da" />
          <text x="200" y="48" fill="#1f2328" font-size="14" font-weight="600" text-anchor="middle">RoleBinding</text>
          <text x="200" y="66" fill="#656d76" font-size="12" text-anchor="middle">subjects, roleRef</text>
          <path d="M252 55 L276 55" stroke="#1a7f37" stroke-width="2" />
          <rect x="276" y="24" width="100" height="62" rx="6" fill="#eaeef2" stroke="#1a7f37" />
          <text x="326" y="48" fill="#1f2328" font-size="14" font-weight="600" text-anchor="middle">User</text>
          <text x="326" y="66" fill="#656d76" font-size="12" text-anchor="middle">permissions</text>
        </svg>
        <figcaption>RBAC: Role defines permissions; RoleBinding binds Role to User/Group/ServiceAccount.</figcaption>
      </figure>

      <!-- 08 Storage -->
      <h2 id="section-08">08 — Storage</h2>
      <h3>Persistent Volume (PV) and Persistent Volume Claim (PVC)</h3>
      <p>PV is <strong>cluster-scoped</strong> storage (admin provisions); PVC is <strong>namespace-scoped</strong>
        (user requests storage). They bind when capacity and <code>accessModes</code> match. If no PV matches, PVC stays
        <strong>Pending</strong>. Access modes: ReadWriteOnce (RWO), ReadOnlyMany (ROX), ReadWriteMany (RWX).
      </p>
      <figure class="diagram">
        <svg viewBox="0 0 500 110" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">
          <rect x="24" y="24" width="130" height="62" rx="6" fill="#eaeef2" stroke="#0969da" />
          <text x="89" y="48" fill="#1f2328" font-size="15" font-weight="600" text-anchor="middle">PV</text>
          <text x="89" y="66" fill="#656d76" font-size="13" text-anchor="middle">cluster-scoped</text>
          <path d="M154 55 L178 55" stroke="#1a7f37" stroke-width="2" />
          <rect x="178" y="24" width="130" height="62" rx="6" fill="#eaeef2" stroke="#0969da" />
          <text x="243" y="48" fill="#1f2328" font-size="15" font-weight="600" text-anchor="middle">PVC</text>
          <text x="243" y="66" fill="#656d76" font-size="13" text-anchor="middle">namespace-scoped</text>
          <path d="M308 55 L332 55" stroke="#1a7f37" stroke-width="2" />
          <rect x="332" y="24" width="130" height="62" rx="6" fill="#eaeef2" stroke="#1a7f37" />
          <text x="397" y="48" fill="#1f2328" font-size="15" font-weight="600" text-anchor="middle">Pod</text>
          <text x="397" y="66" fill="#656d76" font-size="13" text-anchor="middle">volumeMounts</text>
        </svg>
        <figcaption>Storage flow: PV (pool) → PVC (claim) → Pod (volumeMounts). PVC and Pod must be in same namespace.
        </figcaption>
      </figure>
      <div class="snippet-label">PV definition</div>
      <pre><code>kind: PersistentVolume
apiVersion: v1
metadata:
  name: pv-vol1
spec:
  accessModes: ["ReadWriteOnce"]
  capacity:
    storage: 1Gi
  hostPath:
    path: /tmp/data</code></pre>
      <div class="snippet-label">PVC definition</div>
      <pre><code>kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: myclaim
spec:
  accessModes: ["ReadWriteOnce"]
  resources:
    requests:
      storage: 1Gi</code></pre>
      <pre><code>kubectl create -f pv-definition.yaml
kubectl create -f pvc-definition.yaml
kubectl get pv
kubectl get pvc
kubectl delete pvc myclaim
kubectl delete pv pv-vol1</code></pre>

      <h3>Using PVC in a pod</h3>
      <pre><code>apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  containers:
  - name: myfrontend
    image: nginx
    volumeMounts:
    - mountPath: "/var/www/html"
      name: web
  volumes:
  - name: web
    persistentVolumeClaim:
      claimName: myclaim</code></pre>
      <pre><code>kubectl create -f pod-definition.yaml
kubectl get pod,pvc,pv</code></pre>

      <h3>StorageClass (dynamic provisioning)</h3>
      <p>With a StorageClass, PVC can trigger automatic PV creation (no manual PV).</p>
      <pre><code>apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: google-storage
provisioner: kubernetes.io/gce-pd</code></pre>
      <pre><code>kubectl create -f sc-definition.yaml
kubectl get sc</code></pre>
      <p>In PVC add <code>storageClassName: google-storage</code>. Then create PVC and use <code>claimName</code> in pod
        volume as above.</p>

      <!-- 09 Networking -->
      <h2 id="section-09">09 — Networking</h2>

      <h3>Networking prerequisites — Linux basics</h3>
      <p>Understanding Linux networking is essential for the CKA. Key commands:</p>
      <div class="snippet-label">Switching, routing, gateways</div>
      <pre><code># List network interfaces
ip link
ip addr

# Assign IP address to interface
ip addr add 192.168.1.10/24 dev eth0

# View routing table
ip route show
route

# Add route
ip route add 192.168.2.0/24 via 192.168.1.1

# Default gateway
ip route add default via 192.168.1.1

# Enable IP forwarding (required for routing between networks)
cat /proc/sys/net/ipv4/ip_forward   # 0=disabled, 1=enabled
echo 1 > /proc/sys/net/ipv4/ip_forward
# Permanent: set net.ipv4.ip_forward=1 in /etc/sysctl.conf
sysctl --system</code></pre>
      <div class="snippet-label">Network namespaces (how containers get isolated networking)</div>
      <pre><code># Create network namespace
ip netns add red
ip netns add blue

# List namespaces
ip netns

# Run command in namespace
ip netns exec red ip link
ip -n red link

# Connect namespaces with veth pair
ip link add veth-red type veth peer name veth-blue
ip link set veth-red netns red
ip link set veth-blue netns blue
ip -n red addr add 192.168.15.1/24 dev veth-red
ip -n blue addr add 192.168.15.2/24 dev veth-blue
ip -n red link set veth-red up
ip -n blue link set veth-blue up</code></pre>

      <h3>Pod Networking &amp; CNI</h3>
      <p>Kubernetes uses the <strong>Container Network Interface (CNI)</strong> standard to manage networking.
        <br><em>Core Responsibilities of CNI Plugin:</em>
        <br>1. <strong>Connectivity:</strong> Insert a network interface into the container's namespace.
        <br>2. <strong>IPAM (IP Address Management):</strong> Assign an IP address to the pod from the Pod CIDR.
      </p>

      <p><em>Golden Rules:</em>
        <br>- Every Pod gets a unique IP.
        <br>- Pods on the same node talk via <code>localhost</code>/bridge.
        <br>- Pods on different nodes talk directly without NAT (Network Address Translation).
      </p>

      <pre><code># Check CNI configuration
ls /etc/cni/net.d/
cat /etc/cni/net.d/10-flannel.conflist

# Check CNI binaries
ls /opt/cni/bin/

# Identify Pod CIDR (allocated to node)
kubectl get node -o jsonpath='{.spec.podCIDR}'</code></pre>

      <h3>Service Networking (The "Magic" VIP)</h3>
      <p>A Service provides a stable <strong>ClusterIP</strong> (Virtual IP) that load balances traffic to dynamic Pod
        IPs.
        <br><strong>Service:</strong> The abstraction (stable VIP).
        <br><strong>Endpoints:</strong> The actual list of backend Pod IPs. Checked via
        <code>kubectl get endpoints</code>.
      </p>

      <p><em>Mechanism:</em> <strong>kube-proxy</strong> runs on every node and watches the API server. It updates node
        network rules (usually <strong>iptables</strong> or <strong>IPVS</strong>) to trap traffic destined for the
        Service IP and redirect it to a random backing Pod IP.</p>

      <pre><code># View iptables rules for a service
iptables-save | grep &lt;service-name&gt;

# Check kube-proxy mode
kubectl logs -n kube-system -l k8s-app=kube-proxy</code></pre>

      <h3>DNS (CoreDNS)</h3>
      <p><strong>CoreDNS</strong> is the cluster's internal DNS server. It watches the API server for new Services and
        Pods and creates DNS records.
        <br><em>Config:</em> The <strong>Corefile</strong> (inside a ConfigMap) defines behavior (plugins like
        <code>errors</code>, <code>health</code>, <code>kubernetes</code>, <code>forward</code>).
      </p>

      <p><strong>FQDN (Fully Qualified Domain Name) Structure:</strong>
        <br>Service: <code>my-svc.my-ns.svc.cluster.local</code>
        <br>Pod: <code>1-2-3-4.my-ns.pod.cluster.local</code> (IP with dashes)
      </p>

      <pre><code># Test DNS from a debug pod
kubectl run -it --rm debug --image=busybox:1.28 -- nslookup kubernetes
kubectl get configmap coredns -n kube-system -o yaml</code></pre>

      <h3>Ingress</h3>
      <p>Need an Ingress controller (e.g. nginx-ingress) and Ingress resources (rules). Ingress exposes HTTP/HTTPS
        routes to services.</p>
      <div class="snippet-label">Ingress with paths</div>
      <pre><code>apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: ingress-wear-watch
spec:
  rules:
  - http:
      paths:
      - path: /wear
        pathType: Prefix
        backend:
          service:
            name: wear-service
            port:
              number: 80
      - path: /watch
        pathType: Prefix
        backend:
          service:
            name: watch-service
            port:
              number: 80</code></pre>
      <div class="snippet-label">Ingress with host rules</div>
      <pre><code>apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: ingress-wear-watch
spec:
  rules:
  - host: wear.my-online-store.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: wear-service
            port:
              number: 80
  - host: watch.my-online-store.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: watch-service
            port:
              number: 80</code></pre>
      <pre><code>kubectl create -f ingress.yaml
kubectl get ingress
kubectl describe ingress ingress-wear-watch</code></pre>

      <h3>Gateway API</h3>
      <p>The <strong>Gateway API</strong> is the newer, more expressive way to expose HTTP/gRPC/TCP routes (successor
        concept to Ingress). Key resources: <code>Gateway</code> (infrastructure that receives traffic),
        <code>HTTPRoute</code> (rules for routing to backends). Install a Gateway controller (e.g. Gateway API
        implementation) and create Gateway + HTTPRoute resources. The exam may reference it; know it exists as the
        evolution of Ingress.
      </p>

      <!-- 10 Design & Install -->
      <h2 id="section-10">10 — Design and Install Kubernetes Cluster</h2>
      <p><strong>Design:</strong> Plan control-plane count (HA = multiple masters), etcd (stacked with API server or
        external cluster), load balancer in front of API servers. Choose node sizing and networking (pod CIDR, service
        CIDR).</p>
      <p><strong>High availability:</strong> Multiple API server replicas behind a load balancer; etcd cluster (odd
        number, 3 or 5); scheduler and controller manager can run as active/standby (only one active).</p>

      <!-- 11 kubeadm -->
      <h2 id="section-11">11 — Install Kubernetes the kubeadm Way</h2>
      <p><strong>kubeadm</strong> bootstraps the control plane and generates certs, manifests, and kubeconfig. You then
        join worker nodes with <code>kubeadm join</code>. The exam rarely asks for a full install; <strong>upgrading an
          existing cluster</strong> (kubeadm upgrade plan / apply, drain/uncordon workers) is frequently tested.</p>
      <h4>kubeadm init steps (reference)</h4>
      <div class="snippet-label">Prerequisites on all nodes</div>
      <pre><code># Disable swap (required)
sudo swapoff -a
sed -i '/ swap / s/^/#/' /etc/fstab

# Enable kernel modules
cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/k8s.conf
overlay
br_netfilter
EOF
sudo modprobe overlay
sudo modprobe br_netfilter

# Sysctl params
cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-iptables  = 1
net.bridge.bridge-nf-call-ip6tables = 1
net.ipv4.ip_forward                 = 1
EOF
sudo sysctl --system

# Install containerd, kubeadm, kubelet, kubectl
# (follow official docs for your OS)
sudo apt-get update
sudo apt-get install -y kubelet kubeadm kubectl
sudo apt-mark hold kubelet kubeadm kubectl</code></pre>
      <div class="snippet-label">Control plane init</div>
      <pre><code># Initialize control plane
sudo kubeadm init --pod-network-cidr=10.244.0.0/16 --apiserver-advertise-address=&lt;master-ip&gt;

# Copy kubeconfig
mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config

# Install CNI (e.g. Flannel)
kubectl apply -f https://raw.githubusercontent.com/flannel-io/flannel/master/Documentation/kube-flannel.yml</code></pre>
      <div class="snippet-label">Join workers</div>
      <pre><code># On worker nodes (use token from kubeadm init output):
sudo kubeadm join &lt;master-ip&gt;:6443 --token &lt;token&gt; --discovery-token-ca-cert-hash sha256:&lt;hash&gt;

# If token expired, create a new one on master:
kubeadm token create --print-join-command</code></pre>

      <!-- 12 Troubleshooting -->
      <h2 id="section-12">12 — Troubleshooting</h2>
      <h3>Application failure — step-by-step</h3>
      <ul class="step-list">
        <li><strong>Is the service reachable?</strong> <code>curl http://&lt;node-ip&gt;:&lt;nodePort&gt;</code> or from
          inside cluster <code>curl http://&lt;svc-name&gt;.&lt;ns&gt;.svc.cluster.local:port</code>.</li>
        <li><strong>Does the service have endpoints?</strong> <code>kubectl get endpoints &lt;service-name&gt;</code>.
          If empty, the service selector does not match any pod (wrong labels or pods not ready).</li>
        <li><strong>Compare selector with pod labels:</strong> <code>kubectl describe service &lt;name&gt;</code> (see
          Selector) and <code>kubectl get pods --show-labels</code>. Fix selector or pod labels.</li>
        <li><strong>Pod status:</strong> <code>kubectl get pods</code>,
          <code>kubectl describe pod &lt;pod-name&gt;</code>. Check events (image pull, CrashLoopBackOff, etc.).
        </li>
        <li><strong>Container logs:</strong> <code>kubectl logs &lt;pod-name&gt;</code>,
          <code>kubectl logs &lt;pod-name&gt; -c &lt;container&gt;</code>,
          <code>kubectl logs &lt;pod-name&gt; --previous</code> for crashed container.
        </li>
      </ul>
      <pre><code>kubectl get pods -o wide
kubectl describe pod &lt;pod-name&gt;
kubectl logs &lt;pod-name&gt; -f --previous</code></pre>

      <h3>Control plane failure</h3>
      <p>Verify nodes are Ready, then check control-plane components. With kubeadm they are pods in
        <code>kube-system</code>; with manual install they are often systemd services.
      </p>
      <pre><code>kubectl get nodes
kubectl get pods -n kube-system
service kube-apiserver status
service kube-controller-manager status
service kube-scheduler status
service kubelet status
kubectl logs kube-apiserver-master -n kube-system
sudo journalctl -u kube-apiserver</code></pre>

      <h3>Worker node failure</h3>
      <p>If a node is <strong>NotReady</strong>, check <code>kubectl describe node &lt;node&gt;</code> (conditions,
        LastHeartbeatTime). On the node: kubelet status, logs, and cert validity (kubelet may have expired cert).</p>
      <pre><code>kubectl get nodes
kubectl describe node worker-1
service kubelet status
sudo journalctl -u kubelet
openssl x509 -in /var/lib/kubelet/worker-1.crt -text</code></pre>
      <h4>Common worker node issues checklist</h4>
      <ul>
        <li><code>kubelet</code> not running → <code>systemctl start kubelet</code>, check
          <code>journalctl -u kubelet</code>
        </li>
        <li>Config error → check <code>/var/lib/kubelet/config.yaml</code> and <code>/etc/kubernetes/kubelet.conf</code>
        </li>
        <li>Expired certificates → check cert dates with <code>openssl x509 -in &lt;cert&gt; -text -noout</code></li>
        <li>Node conditions: <code>MemoryPressure</code>, <code>DiskPressure</code>, <code>PIDPressure</code> → check
          resources</li>
        <li>Container runtime down → <code>systemctl status containerd</code></li>
      </ul>

      <h3>Network troubleshooting</h3>
      <p>When pods cannot communicate across nodes or DNS fails:</p>
      <ul class="step-list">
        <li><strong>Check CNI plugin:</strong> <code>kubectl get pods -n kube-system</code> — are Calico/Flannel/Weave
          pods running? Check logs.</li>
        <li><strong>CoreDNS running?</strong> <code>kubectl get pods -n kube-system -l k8s-app=kube-dns</code>. If
          CrashLooping, check <code>kubectl logs &lt;coredns-pod&gt; -n kube-system</code>.</li>
        <li><strong>DNS resolution:</strong>
          <code>kubectl run test --image=busybox:1.28 --rm -it --restart=Never -- nslookup kubernetes</code>
        </li>
        <li><strong>kube-proxy running?</strong> <code>kubectl get ds kube-proxy -n kube-system</code>. Check iptables
          rules: <code>iptables -L -t nat | grep &lt;svc&gt;</code></li>
        <li><strong>Node networking:</strong> <code>ip link</code>, <code>ip addr</code>, <code>ip route</code> on
          affected node. Check IP forwarding: <code>cat /proc/sys/net/ipv4/ip_forward</code></li>
        <li><strong>Firewall/port issues:</strong> Ensure required ports are open (6443, 2379-2380, 10250-10252,
          30000-32767)</li>
      </ul>
      <pre><code># Debug networking from inside a pod
kubectl run netshoot --image=nicolaka/netshoot -it --rm --restart=Never -- bash
# Inside: ping, nslookup, curl, traceroute, tcpdump, iperf, etc.

# Test service from inside cluster
kubectl run test --image=busybox:1.28 --rm -it --restart=Never -- wget -qO- http://&lt;svc&gt;.&lt;ns&gt;.svc.cluster.local:&lt;port&gt;</code></pre>

      <!-- 13 Other Topics -->
      <h2 id="section-13">13 — Other Topics</h2>
      <h3>JSON path and custom columns</h3>
      <pre><code>kubectl get nodes -o json
kubectl get pods -o json
kubectl get pods -o=jsonpath='{.items[0].spec.containers[0].image}'
kubectl get pods -o=jsonpath='{.items[*].metadata.name}'
kubectl get nodes -o=custom-columns=NODE:.metadata.name,CPU:.status.capacity.cpu
kubectl get nodes --sort-by=.metadata.name
kubectl get nodes --sort-by=.status.capacity.cpu</code></pre>

      <h3>2025 curriculum: Helm and Kustomize</h3>
      <p><strong>Helm</strong> packages Kubernetes manifests into <strong>charts</strong>. Use for cluster components
        and repeatable installs. Common commands: <code>helm install &lt;release&gt; &lt;chart&gt;</code>,
        <code>helm upgrade</code>, <code>helm list</code>, <code>helm uninstall</code>. Add repos:
        <code>helm repo add &lt;name&gt; &lt;url&gt;</code>, <code>helm repo update</code>.
      </p>
      <p><strong>Kustomize</strong> customizes base YAML (overlays, patches, common labels). Built into kubectl:
        <code>kubectl apply -k &lt;dir&gt;</code> or <code>kustomize build &lt;dir&gt; | kubectl apply -f -</code>.
        Typical layout: <code>base/</code> (resources) + <code>kustomization.yaml</code>; overlays (e.g.
        <code>dev/</code>, <code>prod/</code>) reference the base and add patches.
      </p>

      <h3>CRDs and operators</h3>
      <p><strong>Custom Resource Definitions (CRDs)</strong> extend the API with custom resources. After defining a CRD,
        you get new resource types (e.g. <code>kubectl get myresource</code>). <strong>Operators</strong> are
        controllers that manage custom resources and their lifecycle (install, upgrade, backup). They use CRDs + a
        controller process. List CRDs: <code>kubectl get crd</code>.</p>

      <h3>Extension interfaces: CNI, CSI, CRI</h3>
      <p>Kubernetes uses pluggable interfaces. <strong>CNI</strong> (Container Network Interface): pod networking;
        plugins (Calico, Flannel, Weave) implement the pod network. <strong>CSI</strong> (Container Storage Interface):
        storage drivers for PVs; dynamic provisioning via StorageClass uses a CSI driver. <strong>CRI</strong>
        (Container Runtime Interface): container runtimes (containerd, CRI-O); kubelet talks to the runtime via CRI.
        Configure/validate these when installing or troubleshooting the cluster.</p>

      <!-- 14 Playground & Labs -->
      <h2 id="section-14">14 — Playground &amp; Lightning Labs</h2>
      <p>Use the links below to practice in a real cluster, then try the scenarios on your own before revealing the
        solution.</p>

      <h3>Online playgrounds</h3>
      <ul class="playground-links">
        <li>
          <a href="https://killercoda.com/kubernetes" target="_blank" rel="noopener noreferrer">Killercoda —
            Kubernetes</a>
          <div class="link-desc">Free browser-based Kubernetes labs; no local install. Multiple CKA-focused scenarios.
          </div>
        </li>
        <li>
          <a href="https://www.katacoda.com/courses/kubernetes" target="_blank" rel="noopener noreferrer">Katacoda
            (legacy)</a>
          <div class="link-desc">Kubernetes playgrounds (some scenarios may be deprecated; Killercoda is the successor).
          </div>
        </li>
        <li>
          <a href="https://labs.play-with-k8s.com/" target="_blank" rel="noopener noreferrer">Play with Kubernetes</a>
          <div class="link-desc">Spin up a temporary cluster in the browser; good for quick tests.</div>
        </li>
        <li>
          <a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/" target="_blank"
            rel="noopener noreferrer">Kubernetes Basics (official)</a>
          <div class="link-desc">Official interactive tutorial with an in-browser terminal.</div>
        </li>
      </ul>

      <h3>Practice scenarios (try yourself, then reveal solution)</h3>

      <div class="playground-scenario">
        <h4>Scenario 1: Deployment and Service</h4>
        <p class="playground-context">Namespace <code>app</code> exists. Create a deployment and expose it.</p>
        <p class="playground-task"><strong>Task:</strong> Create a deployment named <code>nginx-deploy</code> with image
          <code>nginx:1.21</code>, 3 replicas. Expose it as a ClusterIP service <code>nginx-svc</code> on port 80. Use
          namespace <code>app</code>.
        </p>
        <button type="button" class="playground-toggle" aria-expanded="false">Show solution</button>
        <div class="playground-solution">
          <pre><code>kubectl create deployment nginx-deploy --image=nginx:1.21 --replicas=3 -n app
kubectl expose deployment nginx-deploy --name=nginx-svc --port=80 -n app
kubectl get deploy,svc -n app</code></pre>
        </div>
      </div>

      <div class="playground-scenario">
        <h4>Scenario 2: ConfigMap and Pod</h4>
        <p class="playground-context">You need a pod that reads a config value from a ConfigMap.</p>
        <p class="playground-task"><strong>Task:</strong> Create a ConfigMap <code>app-cm</code> with
          <code>APP_ENV=production</code>. Create a pod <code>busybox-cm</code> (image <code>busybox:1.28</code>) that
          runs <code>sleep 3600</code> and has environment variable <code>APP_ENV</code> from the ConfigMap.
        </p>
        <button type="button" class="playground-toggle" aria-expanded="false">Show solution</button>
        <div class="playground-solution">
          <pre><code>kubectl create configmap app-cm --from-literal=APP_ENV=production
kubectl run busybox-cm --image=busybox:1.28 --restart=Never -- sleep 3600 --overrides='
{"spec":{"containers":[{"name":"busybox-cm","image":"busybox:1.28","command":["sleep","3600"],"env":[{"name":"APP_ENV","valueFrom":{"configMapKeyRef":{"name":"app-cm","key":"APP_ENV"}}}]}]}}'</code></pre>
          <p style="margin-top:0.75rem;font-size:0.9rem;">Or create a YAML file with <code>env</code> and
            <code>valueFrom.configMapKeyRef</code> and <code>kubectl apply -f</code>.
          </p>
        </div>
      </div>

      <div class="playground-scenario">
        <h4>Scenario 3: Node selector and drain</h4>
        <p class="playground-context">Node <code>worker-1</code> has label <code>disk=ssd</code>. You need to run a pod
          there and later drain the node.</p>
        <p class="playground-task"><strong>Task:</strong> Create a pod <code>ssd-pod</code> (image
          <code>nginx:alpine</code>) that is scheduled only on nodes with <code>disk=ssd</code>. Then cordon and drain
          <code>worker-1</code> (ignore DaemonSet pods).
        </p>
        <button type="button" class="playground-toggle" aria-expanded="false">Show solution</button>
        <div class="playground-solution">
          <pre><code>kubectl run ssd-pod --image=nginx:alpine --restart=Never --overrides='
{"spec":{"nodeSelector":{"disk":"ssd"}}}'
kubectl cordon worker-1
kubectl drain worker-1 --ignore-daemonsets --delete-emptydir-data</code></pre>
        </div>
      </div>

      <!-- 15 Mock Exams -->
      <h2 id="section-15">15 — Mock Exams</h2>
      <p>Time yourself (e.g. 10–15 minutes per question). Complete the task in your cluster or playground, then check
        the solution.</p>

      <div class="mock-question">
        <h4>Mock 1: RBAC — read-only pods in a namespace</h4>
        <p class="mock-context">Namespace <code>dev</code> exists. A user/service account should only list and get pods
          in <code>dev</code>, no create/delete.</p>
        <p class="mock-task"><strong>Task:</strong> Create a Role that allows <code>get</code>, <code>list</code> on
          <code>pods</code> in namespace <code>dev</code>. Create a RoleBinding binding that Role to a user named
          <code>jane</code>.
        </p>
        <button type="button" class="solution-toggle" aria-expanded="false">Show solution</button>
        <div class="mock-solution">
          <pre><code>kubectl create role pod-reader --verb=get,list --resource=pods -n dev
kubectl create rolebinding jane-pod-reader --role=pod-reader --user=jane -n dev</code></pre>
          <p style="margin-top:0.5rem;font-size:0.9rem;">Or apply YAML with <code>kind: Role</code> (rules with
            apiGroups <code>[""]</code>, resources <code>["pods"]</code>, verbs <code>["get","list"]</code>) and
            <code>kind: RoleBinding</code> (roleRef, subjects with name <code>jane</code>).
          </p>
        </div>
      </div>

      <div class="mock-question">
        <h4>Mock 2: Multi-container pod and logs</h4>
        <p class="mock-context">A pod has two containers: <code>main</code> and <code>sidecar</code>. It is failing and
          you need to inspect the previous instance’s logs.</p>
        <p class="mock-task"><strong>Task:</strong> Write the exact <code>kubectl logs</code> command to stream logs
          from the <strong>previous</strong> instance of the <code>sidecar</code> container in pod
          <code>myapp-pod</code> (namespace <code>default</code>).
        </p>
        <button type="button" class="solution-toggle" aria-expanded="false">Show solution</button>
        <div class="mock-solution">
          <pre><code>kubectl logs myapp-pod -c sidecar --previous -f</code></pre>
          <p style="margin-top:0.5rem;font-size:0.9rem;"><code>-c sidecar</code> selects the container,
            <code>--previous</code> shows the crashed/previous instance, <code>-f</code> streams.
          </p>
        </div>
      </div>

      <div class="mock-question">
        <h4>Mock 3: Static pod</h4>
        <p class="mock-context">The control plane uses static pods. You need to run a static pod that runs
          <code>busybox</code> with <code>sleep 3600</code>.
        </p>
        <p class="mock-task"><strong>Task:</strong> Create a static pod manifest (YAML) named
          <code>static-busybox</code> on the control plane node. Assume the static pod path is
          <code>/etc/kubernetes/manifests</code>. Provide the manifest path and key fields.
        </p>
        <button type="button" class="solution-toggle" aria-expanded="false">Show solution</button>
        <div class="mock-solution">
          <pre><code># File: /etc/kubernetes/manifests/static-busybox.yaml
apiVersion: v1
kind: Pod
metadata:
  name: static-busybox
  namespace: default
spec:
  containers:
  - name: busybox
    image: busybox:1.28
    command: ["sleep", "3600"]</code></pre>
          <p style="margin-top:0.5rem;font-size:0.9rem;">Copy this file to the control plane node at
            <code>/etc/kubernetes/manifests/</code>. Kubelet will create the pod. No <code>kubectl apply</code> needed.
          </p>
        </div>
      </div>

      <div class="mock-question">
        <h4>Mock 4: Service and endpoints</h4>
        <p class="mock-context">A service <code>web-svc</code> in namespace <code>prod</code> is not getting traffic.
          Pods are running with label <code>app=web</code>.</p>
        <p class="mock-task"><strong>Task:</strong> (1) Check if the service has endpoints. (2) If empty, fix the
          service so it targets pods with label <code>app=web</code>. Assume the service exists but has the wrong
          selector.</p>
        <button type="button" class="solution-toggle" aria-expanded="false">Show solution</button>
        <div class="mock-solution">
          <pre><code>kubectl get endpoints web-svc -n prod
kubectl get svc web-svc -n prod -o yaml   # inspect selector
# Fix: patch or edit so selector is app=web
kubectl patch svc web-svc -n prod -p '{"spec":{"selector":{"app":"web"}}}'
# Or kubectl edit svc web-svc -n prod and set spec.selector.app: web
kubectl get endpoints web-svc -n prod     # should list pod IPs now</code></pre>
        </div>
      </div>

      <div class="mock-question">
        <h4>Mock 5: etcd backup</h4>
        <p class="mock-context">You need to take a snapshot of etcd for disaster recovery. The cluster was set up with
          kubeadm; etcd runs as a pod and listens on <code>https://127.0.0.1:2379</code> with certs under
          <code>/etc/kubernetes/pki/etcd/</code>.
        </p>
        <p class="mock-task"><strong>Task:</strong> Run the <code>etcdctl snapshot save</code> command with the correct
          API version, endpoint, and cert flags. Save to <code>/tmp/etcd-snapshot.db</code>.</p>
        <button type="button" class="solution-toggle" aria-expanded="false">Show solution</button>
        <div class="mock-solution">
          <pre><code>ETCDCTL_API=3 etcdctl snapshot save /tmp/etcd-snapshot.db \
  --endpoints=https://127.0.0.1:2379 \
  --cacert=/etc/kubernetes/pki/etcd/ca.crt \
  --cert=/etc/kubernetes/pki/etcd/server.crt \
  --key=/etc/kubernetes/pki/etcd/server.key</code></pre>
          <p style="margin-top:0.5rem;font-size:0.9rem;">Run from the control plane node (or from inside the etcd pod).
            Verify with <code>ETCDCTL_API=3 etcdctl snapshot status /tmp/etcd-snapshot.db</code>.</p>
        </div>
      </div>

      <div class="mock-question">
        <h4>Mock 6: PV and PVC binding</h4>
        <p class="mock-context">You need to create a PersistentVolume and a PersistentVolumeClaim, then mount it in a
          pod.</p>
        <p class="mock-task"><strong>Task:</strong> Create a PV named <code>pv-log</code> with 100Mi capacity,
          accessMode <code>ReadWriteMany</code>, hostPath <code>/pv/log</code>. Create a PVC named
          <code>claim-log-1</code> requesting 50Mi with <code>ReadWriteMany</code>. Create a pod <code>logger</code>
          (image <code>nginx</code>) mounting the PVC at <code>/var/log/nginx</code>.
        </p>
        <button type="button" class="solution-toggle" aria-expanded="false">Show solution</button>
        <div class="mock-solution">
          <pre><code># pv.yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv-log
spec:
  capacity:
    storage: 100Mi
  accessModes:
  - ReadWriteMany
  hostPath:
    path: /pv/log
---
# pvc.yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: claim-log-1
spec:
  accessModes:
  - ReadWriteMany
  resources:
    requests:
      storage: 50Mi
---
# pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: logger
spec:
  containers:
  - name: nginx
    image: nginx
    volumeMounts:
    - mountPath: /var/log/nginx
      name: log-vol
  volumes:
  - name: log-vol
    persistentVolumeClaim:
      claimName: claim-log-1</code></pre>
          <pre><code>kubectl apply -f pv.yaml -f pvc.yaml -f pod.yaml
kubectl get pv,pvc,pod</code></pre>
        </div>
      </div>

      <div class="mock-question">
        <h4>Mock 7: NetworkPolicy — deny all ingress</h4>
        <p class="mock-context">Namespace <code>secure</code> exists with pods labeled <code>app=db</code>. You need to
          deny all ingress traffic except from pods labeled <code>app=api</code> on port 5432.</p>
        <p class="mock-task"><strong>Task:</strong> Create a NetworkPolicy in namespace <code>secure</code> that selects
          pods with label <code>app=db</code>, denies all ingress, and only allows ingress from pods with
          <code>app=api</code> on TCP port 5432.
        </p>
        <button type="button" class="solution-toggle" aria-expanded="false">Show solution</button>
        <div class="mock-solution">
          <pre><code>apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: db-policy
  namespace: secure
spec:
  podSelector:
    matchLabels:
      app: db
  policyTypes:
  - Ingress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: api
    ports:
    - protocol: TCP
      port: 5432</code></pre>
          <pre><code>kubectl apply -f netpol.yaml
kubectl get networkpolicy -n secure
kubectl describe netpol db-policy -n secure</code></pre>
        </div>
      </div>

      <div class="mock-question">
        <h4>Mock 8: Cluster upgrade (kubeadm)</h4>
        <p class="mock-context">Your cluster runs v1.30.0. You need to upgrade the control plane to v1.31.0.</p>
        <p class="mock-task"><strong>Task:</strong> Upgrade kubeadm, then the control plane, then kubelet and kubectl on
          the control plane node. Show the commands in order.</p>
        <button type="button" class="solution-toggle" aria-expanded="false">Show solution</button>
        <div class="mock-solution">
          <pre><code># 1. Upgrade kubeadm
sudo apt-mark unhold kubeadm
sudo apt-get update && sudo apt-get install -y kubeadm=1.31.0-*
sudo apt-mark hold kubeadm

# 2. Plan and apply
sudo kubeadm upgrade plan
sudo kubeadm upgrade apply v1.31.0

# 3. Drain the node
kubectl drain &lt;control-plane-node&gt; --ignore-daemonsets

# 4. Upgrade kubelet and kubectl
sudo apt-mark unhold kubelet kubectl
sudo apt-get install -y kubelet=1.31.0-* kubectl=1.31.0-*
sudo apt-mark hold kubelet kubectl
sudo systemctl daemon-reload
sudo systemctl restart kubelet

# 5. Uncordon
kubectl uncordon &lt;control-plane-node&gt;
kubectl get nodes</code></pre>
        </div>
      </div>

      <div class="mock-question">
        <h4>Mock 9: Ingress with TLS</h4>
        <p class="mock-context">Service <code>webapp-svc</code> exists on port 80 in namespace <code>apps</code>. You
          have a TLS cert and key.</p>
        <p class="mock-task"><strong>Task:</strong> Create a TLS secret <code>webapp-tls</code> and an Ingress
          <code>webapp-ingress</code> that terminates TLS on host <code>webapp.example.com</code> and routes to
          <code>webapp-svc</code>.
        </p>
        <button type="button" class="solution-toggle" aria-expanded="false">Show solution</button>
        <div class="mock-solution">
          <pre><code># Create TLS secret
kubectl create secret tls webapp-tls --cert=tls.crt --key=tls.key -n apps

# Ingress YAML
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: webapp-ingress
  namespace: apps
spec:
  tls:
  - hosts:
    - webapp.example.com
    secretName: webapp-tls
  rules:
  - host: webapp.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: webapp-svc
            port:
              number: 80</code></pre>
        </div>
      </div>

      <div class="mock-question">
        <h4>Mock 10: JSONPath and sorting</h4>
        <p class="mock-context">You need to extract specific information from the cluster using JSONPath.</p>
        <p class="mock-task"><strong>Task:</strong> (1) List all node names sorted by CPU capacity. (2) Output a
          custom-columns table showing pod name and container image for all pods in all namespaces. (3) Get the
          InternalIP of all nodes.</p>
        <button type="button" class="solution-toggle" aria-expanded="false">Show solution</button>
        <div class="mock-solution">
          <pre><code># 1. Nodes sorted by CPU
kubectl get nodes --sort-by=.status.capacity.cpu

# 2. Custom columns: pod name + image
kubectl get pods -A -o=custom-columns='NAME:.metadata.name,IMAGE:.spec.containers[*].image'

# 3. InternalIP of all nodes
kubectl get nodes -o jsonpath='{.items[*].status.addresses[?(@.type=="InternalIP")].address}'

# Alternative using range for formatted output:
kubectl get nodes -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.status.addresses[?(@.type=="InternalIP")].address}{"\n"}{end}'</code></pre>
        </div>
      </div>

      <h2 id="section-16">16 — Ultimate Mocks</h2>
      <p>Extended scenario-based mocks: multi-step troubleshooting, storage (PV/PVC), networking (NetworkPolicy,
        Ingress), and cluster upgrades. Use the same format: try the scenario in a playground, then compare with the
        solutions in the course docs or your notes.</p>
      <p><strong>Ultimate mock strategy:</strong> Set a 2-hour timer, attempt all questions sequentially. Flag hard
        questions and return to them. Prioritize high-weight questions (troubleshooting = 30%). Practice with Killer.sh
        (free retake included with CKA exam purchase).</p>

      <h2 id="section-17">17 — Tips and Tricks</h2>
      <h3>Exam environment setup (do this first!)</h3>
      <p>The CKA exam uses a browser-based terminal. Set up shortcuts immediately:</p>
      <div class="snippet-label">Shell aliases and settings (~/.bashrc)</div>
      <pre><code># Essential aliases — set these at the START of the exam
alias k=kubectl
alias kn='kubectl config set-context --current --namespace'
alias kgp='kubectl get pods'
alias kgs='kubectl get svc'
alias kgn='kubectl get nodes'
alias kga='kubectl get all'
alias kaf='kubectl apply -f'
alias kdp='kubectl describe pod'
alias kl='kubectl logs'
alias ke='kubectl exec -it'

# Enable kubectl autocompletion
source <(kubectl completion bash)
complete -o default -F __start_kubectl k

# Set default editor
export KUBE_EDITOR=vi
# or
export EDITOR=vi</code></pre>
      <div class="snippet-label">Vim settings (~/.vimrc)</div>
      <pre><code># Paste this into ~/.vimrc for YAML editing
set tabstop=2
set shiftwidth=2
set expandtab
set number
set autoindent</code></pre>

      <h3>Time management</h3>
      <ul>
        <li><strong>2 hours, ~17 questions.</strong> Average ~7 minutes per question.</li>
        <li><strong>Don't get stuck:</strong> Flag difficult questions, move on, come back.</li>
        <li><strong>High-weight first:</strong> Prioritize questions worth more marks.</li>
        <li><strong>Use imperative commands:</strong> Faster than writing YAML from scratch.</li>
        <li><strong>Bookmark the docs:</strong> Kubernetes.io docs are allowed. Pre-bookmark key pages.</li>
      </ul>

      <h3>Essential bookmarks for the exam</h3>
      <ul>
        <li><a href="https://kubernetes.io/docs/reference/kubectl/cheatsheet/" target="_blank" rel="noopener">kubectl
            Cheat Sheet</a></li>
        <li><a href="https://kubernetes.io/docs/concepts/" target="_blank" rel="noopener">Concepts</a> → Workloads,
          Services, Storage, Config</li>
        <li><a href="https://kubernetes.io/docs/tasks/" target="_blank" rel="noopener">Tasks</a> → Administer a Cluster,
          Manage TLS, Configure Pods</li>
        <li><a href="https://kubernetes.io/docs/reference/" target="_blank" rel="noopener">API Reference</a></li>
      </ul>

      <h3>Test pods for networking</h3>
      <p>Run a temporary pod for DNS/connectivity tests:
        <code>kubectl run dnsutils --image=busybox:1.28 --restart=Never --rm -it -- nslookup kubernetes.default.svc.cluster.local</code>.
        For a long-lived debug pod:
        <code>kubectl run debug --image=nicolaka/netshoot -it --rm --restart=Never -- bash</code>.
      </p>

      <h3>Useful one-liners</h3>
      <pre><code># All pods with node info
kubectl get pods -A -o wide

# Events sorted by time
kubectl get events -A --sort-by='.lastTimestamp'

# Node resource usage
kubectl describe node | grep -A5 "Allocated resources"

# Set default namespace
kubectl config set-context --current --namespace=&lt;ns&gt;

# Find which node a pod runs on
kubectl get pod &lt;name&gt; -o jsonpath='{.spec.nodeName}'

# Watch pods (live updates)
kubectl get pods -w

# Delete a pod stuck in Terminating
kubectl delete pod &lt;name&gt; --force --grace-period=0

# Get all images running in the cluster
kubectl get pods -A -o jsonpath='{range .items[*]}{.spec.containers[*].image}{"\n"}{end}' | sort | uniq

# Check component statuses
kubectl get componentstatuses   # may be deprecated
kubectl get --raw='/readyz?verbose'

# Quick pod for testing
kubectl run tmp --image=busybox:1.28 --rm -it --restart=Never -- sh

# Decode a secret
kubectl get secret &lt;name&gt; -o jsonpath='{.data.password}' | base64 --decode

# Find static pod manifests path
ps aux | grep kubelet | grep config
grep staticPodPath /var/lib/kubelet/config.yaml</code></pre>

      <h3>Common exam mistakes to avoid</h3>
      <ul>
        <li>❌ Forgetting to switch context (<code>kubectl config use-context &lt;context&gt;</code>) — each question may
          use a different cluster</li>
        <li>❌ Wrong namespace — always check the question for namespace and use <code>-n &lt;ns&gt;</code></li>
        <li>❌ YAML indentation errors — use <code>kubectl apply -f file.yaml</code> and read the error</li>
        <li>❌ Not verifying the answer — always run <code>kubectl get</code> / <code>kubectl describe</code> to confirm
        </li>
        <li>❌ Spending too long on one question — flag it and move on</li>
        <li>❌ Forgetting <code>--dry-run=client -o yaml</code> — the fastest way to generate templates</li>
      </ul>

      <!--18 Cheat Sheet -->
      <h2 id="section-18">18 — CKA Exam Cheat Sheet</h2>
      <p>Quick-reference cards for every exam domain. Print this section or keep it open during practice sessions. Each
        card contains the most commonly tested commands and YAML patterns from exam dumps.</p>

      <div class="cheat-grid">

        <div class="cheat-card">
          <div class="cheat-card-header">
            <h4>kubectl Quick Reference</h4>
          </div>
          <div class="cheat-card-body">
            <pre><code># Create resources fast
k run pod1 --image=nginx
k create deploy d1 --image=nginx --replicas=3
k expose deploy d1 --port=80 --name=d1-svc
k create ns dev
k create sa my-sa
k create cm cfg --from-literal=k=v
k create secret generic s1 --from-literal=p=s
k create job j1 --image=busybox -- echo hi
k create cronjob cj --image=b --schedule="* * * * *" -- sh

# Generate YAML
k run x --image=nginx --dry-run=client -o yaml > x.yaml
k create deploy x --image=nginx --dry-run=client -o yaml

# Inspect
k get pods -A -o wide
k describe pod &lt;name&gt;
k logs &lt;pod&gt; -c &lt;container&gt; --previous
k exec -it &lt;pod&gt; -- sh
k get events --sort-by='.lastTimestamp'

# Edit / Patch / Replace
k edit deploy &lt;name&gt;
k patch svc s1 -p '{"spec":{"type":"NodePort"}}'
k replace --force -f pod.yaml
k delete pod x --force --grace-period=0

# Context & Namespace
k config use-context &lt;ctx&gt;
k config set-context --current --namespace=dev</code></pre>
          </div>
        </div>


        <div class="cheat-card">
          <div class="cheat-card-header">
            <h4>Pod Skeleton</h4>
          </div>
          <div class="cheat-card-body">
            <pre><code>apiVersion: v1
kind: Pod
metadata:
  name: mypod
  namespace: default
  labels:
    app: myapp
spec:
  serviceAccountName: my-sa     # optional
  nodeSelector:                  # optional
    disk: ssd
  tolerations:                   # optional
  - key: "node-role"
    operator: "Exists"
    effect: "NoSchedule"
  initContainers:                # optional
  - name: init
    image: busybox
    command: ['sh','-c','sleep 5']
  containers:
  - name: app
    image: nginx:1.21
    ports:
    - containerPort: 80
    env:
    - name: KEY
      value: val
    envFrom:
    - configMapRef:
        name: my-cm
    - secretRef:
        name: my-secret
    resources:
      requests:
        cpu: 100m
        memory: 128Mi
      limits:
        cpu: 500m
        memory: 256Mi
    livenessProbe:
      httpGet:
        path: /healthz
        port: 80
      initialDelaySeconds: 10
    readinessProbe:
      httpGet:
        path: /ready
        port: 80
    volumeMounts:
    - name: data
      mountPath: /data
    securityContext:
      runAsUser: 1000
      runAsNonRoot: true
      capabilities:
        drop: ["ALL"]
  volumes:
  - name: data
    persistentVolumeClaim:
      claimName: my-pvc
  # OR emptyDir:
  # - name: tmp
  #   emptyDir: {}</code></pre>
          </div>
        </div>


        <div class="cheat-card">
          <div class="cheat-card-header">
            <h4>Deployment + Service</h4>
          </div>
          <div class="cheat-card-body">
            <pre><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  selector:
    matchLabels:
      app: webapp
  template:
    metadata:
      labels:
        app: webapp
    spec:
      containers:
      - name: webapp
        image: nginx:1.21
        ports:
        - containerPort: 80
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
---
apiVersion: v1
kind: Service
metadata:
  name: webapp-svc
spec:
  type: NodePort        # or ClusterIP
  selector:
    app: webapp
  ports:
  - port: 80
    targetPort: 80
    nodePort: 30080     # only for NodePort</code></pre>
          </div>
        </div>


        <div class="cheat-card">
          <div class="cheat-card-header">
            <h4>RBAC Pattern</h4>
          </div>
          <div class="cheat-card-body">
            <pre><code># Imperative (fastest in exam)
k create role dev-role \
  --verb=get,list,create,delete \
  --resource=pods -n dev

k create rolebinding dev-bind \
  --role=dev-role --user=jane -n dev

k create clusterrole node-viewer \
  --verb=get,list --resource=nodes

k create clusterrolebinding node-bind \
  --clusterrole=node-viewer --user=jane

# Check permissions
k auth can-i create pods --as=jane -n dev
k auth can-i '*' '*' --as=system:serviceaccount:default:my-sa

# ServiceAccount in pod
spec:
  serviceAccountName: my-sa</code></pre>
          </div>
        </div>


        <div class="cheat-card">
          <div class="cheat-card-header">
            <h4>ETCD Backup & Restore</h4>
          </div>
          <div class="cheat-card-body">
            <pre><code># BACKUP
ETCDCTL_API=3 etcdctl snapshot save /tmp/etcd.db \
  --endpoints=https://127.0.0.1:2379 \
  --cacert=/etc/kubernetes/pki/etcd/ca.crt \
  --cert=/etc/kubernetes/pki/etcd/server.crt \
  --key=/etc/kubernetes/pki/etcd/server.key

# Verify
ETCDCTL_API=3 etcdctl snapshot status /tmp/etcd.db

# RESTORE
ETCDCTL_API=3 etcdctl snapshot restore /tmp/etcd.db \
  --data-dir=/var/lib/etcd-restored

# Then update etcd manifest:
vi /etc/kubernetes/manifests/etcd.yaml
# Change: hostPath.path → /var/lib/etcd-restored
# Wait for etcd pod to restart

# Find etcd certs (from pod spec)
k describe pod etcd-master -n kube-system | grep -A5 cert</code></pre>
          </div>
        </div>


        <div class="cheat-card">
          <div class="cheat-card-header">
            <h4>Cluster Upgrade Sequence</h4>
          </div>
          <div class="cheat-card-body">
            <pre><code># === CONTROL PLANE ===
apt-mark unhold kubeadm
apt-get update && apt-get install -y kubeadm=1.XX.0-*
apt-mark hold kubeadm
kubeadm upgrade plan
kubeadm upgrade apply v1.XX.0
kubectl drain &lt;cp-node&gt; --ignore-daemonsets
apt-mark unhold kubelet kubectl
apt-get install -y kubelet=1.XX.0-* kubectl=1.XX.0-*
apt-mark hold kubelet kubectl
systemctl daemon-reload && systemctl restart kubelet
kubectl uncordon &lt;cp-node&gt;

# === WORKER NODES ===
kubectl drain &lt;worker&gt; --ignore-daemonsets
# SSH to worker:
apt-mark unhold kubeadm kubelet
apt-get install -y kubeadm=1.XX.0-* kubelet=1.XX.0-*
kubeadm upgrade node
systemctl daemon-reload && systemctl restart kubelet
apt-mark hold kubeadm kubelet
# Back on control plane:
kubectl uncordon &lt;worker&gt;</code></pre>
          </div>
        </div>


        <div class="cheat-card">
          <div class="cheat-card-header">
            <h4>Storage: PV + PVC + SC</h4>
          </div>
          <div class="cheat-card-body">
            <pre><code># PersistentVolume
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv1
spec:
  capacity:
    storage: 1Gi
  accessModes: [ReadWriteOnce]
  persistentVolumeReclaimPolicy: Retain
  hostPath:
    path: /mnt/data
---
# PersistentVolumeClaim
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc1
spec:
  accessModes: [ReadWriteOnce]
  resources:
    requests:
      storage: 500Mi
  storageClassName: ""   # empty = static binding
---
# StorageClass (dynamic)
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: fast
provisioner: kubernetes.io/gce-pd
parameters:
  type: pd-ssd
reclaimPolicy: Delete
allowVolumeExpansion: true

# Mount in pod:
  volumes:
  - name: data
    persistentVolumeClaim:
      claimName: pvc1
  containers:
  - volumeMounts:
    - mountPath: /data
      name: data</code></pre>
          </div>
        </div>


        <div class="cheat-card">
          <div class="cheat-card-header">
            <h4>Networking Cheat Sheet</h4>
          </div>
          <div class="cheat-card-body">
            <pre><code># NetworkPolicy (allow specific ingress)
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-api
  namespace: prod
spec:
  podSelector:
    matchLabels:
      app: db
  policyTypes: [Ingress, Egress]
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: api
    - namespaceSelector:
        matchLabels:
          env: prod
    ports:
    - port: 3306
  egress:
  - to:
    - podSelector:
        matchLabels:
          app: cache
    ports:
    - port: 6379

# Ingress
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: app-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  rules:
  - host: app.example.com
    http:
      paths:
      - path: /api
        pathType: Prefix
        backend:
          service:
            name: api-svc
            port:
              number: 80</code></pre>
          </div>
        </div>


        <div class="cheat-card">
          <div class="cheat-card-header">
            <h4>Troubleshooting Checklist</h4>
          </div>
          <div class="cheat-card-body">
            <pre><code># 1. Check nodes
k get nodes
k describe node &lt;node&gt;  # conditions, taints

# 2. Check control plane pods
k get pods -n kube-system
k logs kube-apiserver-master -n kube-system
k logs kube-scheduler-master -n kube-system

# 3. Check kubelet (on node)
systemctl status kubelet
journalctl -u kubelet -f
cat /var/lib/kubelet/config.yaml

# 4. Check service &amp; endpoints
k get svc,endpoints &lt;svc-name&gt;
# If endpoints empty → wrong selector

# 5. Pod debugging
k get pods -o wide
k describe pod &lt;name&gt;   # check Events
k logs &lt;pod&gt; --previous
k exec -it &lt;pod&gt; -- sh

# 6. DNS test
k run dns-test --image=busybox:1.28 --rm -it \
  --restart=Never -- nslookup kubernetes

# 7. Network test
k run net-test --image=nicolaka/netshoot \
  --rm -it --restart=Never -- bash

# 8. Certificate check
openssl x509 -in /etc/kubernetes/pki/apiserver.crt \
  -text -noout | grep -A2 Validity</code></pre>
          </div>
        </div>


        <div class="cheat-card">
          <div class="cheat-card-header">
            <h4>DaemonSet / Job / CronJob</h4>
          </div>
          <div class="cheat-card-body">
            <pre><code># DaemonSet
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: log-agent
spec:
  selector:
    matchLabels:
      app: log-agent
  template:
    metadata:
      labels:
        app: log-agent
    spec:
      containers:
      - name: agent
        image: fluentd
---
# Job (run to completion)
apiVersion: batch/v1
kind: Job
metadata:
  name: pi-job
spec:
  completions: 3
  parallelism: 2
  backoffLimit: 4
  template:
    spec:
      containers:
      - name: pi
        image: perl
        command: ["perl","-Mbignum=bpi",
                  "-wle","print bpi(2000)"]
      restartPolicy: Never
---
# CronJob
apiVersion: batch/v1
kind: CronJob
metadata:
  name: backup
spec:
  schedule: "0 2 * * *"
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 1
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: backup
            image: busybox
            command: ["/bin/sh","-c","date"]
          restartPolicy: OnFailure</code></pre>
          </div>
        </div>


        <div class="cheat-card">
          <div class="cheat-card-header">
            <h4>JSONPath & Output</h4>
          </div>
          <div class="cheat-card-body">
            <pre><code># Single value
k get pod x -o jsonpath='{.spec.nodeName}'

# All pod names
k get pods -o jsonpath='{.items[*].metadata.name}'

# Range (formatted)
k get nodes -o jsonpath='
{range .items[*]}
  {.metadata.name}{"\t"}
  {.status.capacity.cpu}{"\n"}
{end}'

# Filter with condition
k get nodes -o jsonpath='
{.items[*].status.addresses
[?(@.type=="InternalIP")].address}'

# Custom columns
k get pods -A -o custom-columns=\
NAME:.metadata.name,\
NODE:.spec.nodeName,\
IMAGE:.spec.containers[0].image

# Sort
k get pods --sort-by=.metadata.creationTimestamp
k get pv --sort-by=.spec.capacity.storage

# Output to file (exam pattern)
k get nodes -o json > /opt/output.json
k get nodes -o jsonpath='{.items[*].status.nodeInfo.osImage}' > /opt/os.txt

# Count
k get pods -A --no-headers | wc -l</code></pre>
          </div>
        </div>


        <div class="cheat-card">
          <div class="cheat-card-header">
            <h4>CSR / Certificates</h4>
          </div>
          <div class="cheat-card-body">
            <pre><code># Generate key + CSR
openssl genrsa -out user.key 2048
openssl req -new -key user.key \
  -subj "/CN=user/O=group" -out user.csr

# Create K8s CSR object
cat user.csr | base64 | tr -d '\n'

apiVersion: certificates.k8s.io/v1
kind: CertificateSigningRequest
metadata:
  name: user
spec:
  request: &lt;base64-csr&gt;
  signerName: kubernetes.io/kube-apiserver-client
  usages: [client auth]

# Approve &amp; extract
k certificate approve user
k get csr user -o jsonpath='{.status.certificate}' \
  | base64 -d > user.crt

# Add to kubeconfig
k config set-credentials user \
  --client-certificate=user.crt \
  --client-key=user.key
k config set-context user-ctx \
  --cluster=kubernetes --user=user
k config use-context user-ctx</code></pre>
          </div>

        </div><!-- end cheat-grid -->

    </main>
    <aside class="right-sidebar" id="right-sidebar">
      <div class="sidebar-title">Quick Links</div>
      <ul>
        <!-- Add your own links below -->
        <li><a href="#section-13">Other Topics</a></li>
        <li><a href="#section-14">Lightning Labs</a></li>
        <li><a href="#section-15">Mock Exams</a></li>
        <li><a href="#section-16">Ultimate Mocks</a></li>
        <li><a href="#section-17">Tips & Tricks</a></li>
        <li><a href="#section-18">Cheat Sheet</a></li>

      </ul>

    </aside>
  </div>
  <footer class="site-footer">
    CKA Study Guide — Reference for Certified Kubernetes Administrator exam preparation.
  </footer>
  <script>
    (function () {
      // ── Core Variables ────────────────────────────────────────────────
      var main = document.querySelector('main');
      var headerH = 56;

      // ── Helper Functions ──────────────────────────────────────────────
      function smoothScrollTo(el) {
        if (!el) return;
        // Immediate snap to top with offset for header (40px) + buffer (10px)
        var offset = 50;
        var targetY = el.getBoundingClientRect().top + main.scrollTop - offset;

        main.scrollTo({
          top: targetY,
          behavior: 'auto'
        });
      }

      function wrapContentBlocks() {
        if (!main) return;
        var intro = document.getElementById('intro');
        if (intro && !document.getElementById('block-intro')) {
          var blockIntro = document.createElement('div');
          blockIntro.id = 'block-intro';
          blockIntro.className = 'content-block is-open';
          intro.parentNode.insertBefore(blockIntro, intro);
          blockIntro.appendChild(intro);
        }
        main.querySelectorAll('h2[id^="section-"]').forEach(function (h2) {
          var id = h2.getAttribute('id');
          if (document.getElementById('block-' + id)) return; // already wrapped

          var block = document.createElement('div');
          block.id = 'block-' + id;
          block.className = 'content-block';
          var nodes = [h2];
          var next = h2.nextElementSibling;
          while (next && next.tagName !== 'H2') {
            nodes.push(next);
            next = next.nextElementSibling;
          }
          h2.parentNode.insertBefore(block, h2);
          nodes.forEach(function (node) { block.appendChild(node); });
        });
      }

      function openBlock(block, skipScroll) {
        if (!block) return;

        // 1. Instantly hide ALL other blocks
        main.querySelectorAll('.content-block').forEach(function (b) {
          if (b !== block) {
            b.classList.remove('is-open');
            b.style.display = 'none'; // Force hide immediately
          }
        });

        // 2. Open current block
        if (!block.classList.contains('is-open')) {
          block.style.display = 'block';
          block.classList.add('is-open');
        }

        // 3. Scroll to top (only if not skipping)
        if (!skipScroll) {
          main.scrollTop = 0; // Reset scroll for cleaner jump
        }
      }

      // ── Initialization & Event Listeners ──────────────────────────────
      document.addEventListener('DOMContentLoaded', function () {

        // 1. Wrap Content
        wrapContentBlocks();

        // 2. Mobile Nav Controls
        var navToggle = document.getElementById('nav-toggle');
        var navClose = document.getElementById('nav-close');
        var nav = document.getElementById('nav');

        function closeMobileNav() {
          nav.classList.remove('is-open');
          if (navToggle) navToggle.setAttribute('aria-label', 'Open menu');
        }

        if (navClose) navClose.addEventListener('click', closeMobileNav);
        if (navToggle && nav) {
          navToggle.addEventListener('click', function (e) {
            e.stopPropagation(); // Prevent immediate close
            nav.classList.toggle('is-open');
            var isOpen = nav.classList.contains('is-open');
            navToggle.setAttribute('aria-label', isOpen ? 'Close menu' : 'Open menu');
            navToggle.setAttribute('aria-expanded', isOpen);
          });
          // Close mob nav when clicking outside
          document.addEventListener('click', function (e) {
            if (nav.classList.contains('is-open') && !nav.contains(e.target) && e.target !== navToggle && !navToggle.contains(e.target))
              closeMobileNav();
          });
        }

        // 3. Desktop Focus Mode Toggles
        const layout = document.querySelector('.layout');
        const toggleLeftBtn = document.getElementById('toggle-left');
        const toggleRightBtn = document.getElementById('toggle-right');

        if (toggleLeftBtn) {
          toggleLeftBtn.addEventListener('click', () => {
            layout.classList.toggle('nav-hidden');
            toggleLeftBtn.classList.toggle('active-toggle');
            // Recalc scroll position if needed
          });
        }

        if (toggleRightBtn) {
          toggleRightBtn.addEventListener('click', () => {
            layout.classList.toggle('sidebar-hidden');
            toggleRightBtn.classList.toggle('active-toggle');
          });
        }

        // 4. Generate Submenus & Attach Listeners
        const navMap = {};
        document.querySelectorAll('h2[id^="section-"]').forEach(h2 => {
          const sectionId = h2.getAttribute('id');
          navMap[sectionId] = [];

          let nextNode = h2.nextElementSibling;
          while (nextNode && nextNode.tagName !== 'H2') {
            if (nextNode.tagName === 'H3') {
              if (!nextNode.id) {
                const text = nextNode.textContent.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '');
                nextNode.id = sectionId + '-' + text;
              }
              navMap[sectionId].push({ id: nextNode.id, text: nextNode.textContent });
            }
            nextNode = nextNode.nextElementSibling;
          }
        });

        // Loop through MAIN nav links to wrap + add listeners
        nav.querySelectorAll('a[href^="#"]').forEach(link => {
          const href = link.getAttribute('href');
          if (href === '#') return;
          const id = href.substring(1);

          // Main Link Click Handler (Accordion Behavior)
          link.addEventListener('click', function (e) {
            e.preventDefault();
            closeMobileNav();

            // handle active state styling
            document.querySelectorAll('.nav-item').forEach(el => el.classList.remove('active'));
            if (this.parentNode.classList.contains('nav-item')) {
              this.parentNode.classList.add('active');
            }

            // Open Block
            var blockId = id === 'intro' ? 'block-intro' : 'block-' + id;
            var block = document.getElementById(blockId);
            if (block) openBlock(block);
          });

          // Submenu Generation (only for #section- links)
          if (id.startsWith('section-')) {
            if (link.parentNode.classList.contains('nav-item')) return; // already processed

            const wrapper = document.createElement('div');
            wrapper.className = 'nav-item';
            link.parentNode.insertBefore(wrapper, link);
            wrapper.appendChild(link);

            if (navMap[id] && navMap[id].length > 0) {
              const subMenu = document.createElement('div');
              subMenu.className = 'nav-submenu';
              navMap[id].forEach(item => {
                const subLink = document.createElement('a');
                subLink.href = '#' + item.id;
                subLink.className = 'nav-sub-link';
                subLink.textContent = item.text;
                subLink.addEventListener('click', (e) => {
                  e.preventDefault();
                  closeMobileNav();
                  e.stopPropagation(); // prevent bubbling to parent

                  // Ensure parent block is open, but DON'T scroll to top yet
                  const blockId = 'block-' + id;
                  const block = document.getElementById(blockId);

                  if (block) {
                    openBlock(block, true); // true = skip scroll to top

                    // Now scroll to the specific subsection
                    // Slight delay ensuring layout is stable
                    setTimeout(() => {
                      const target = document.getElementById(item.id);
                      smoothScrollTo(target);
                    }, 10);
                  }
                });
                subMenu.appendChild(subLink);
              });
              wrapper.appendChild(subMenu);
            }
          }
        });

        // Right Sidebar Links
        var rs = document.getElementById('right-sidebar');
        if (rs) {
          rs.querySelectorAll('a[href^="#"]').forEach(function (a) {
            a.addEventListener('click', function (ev) {
              ev.preventDefault();
              var href = a.getAttribute('href');
              var id = href.substring(1);
              var blockId = id === 'intro' ? 'block-intro' : 'block-' + id;
              var block = document.getElementById(blockId);
              if (block) openBlock(block);
            });
          });
        }

        // Challenge Mode Toggle
        var challengeToggle = document.getElementById('challenge-toggle');
        if (challengeToggle) {
          challengeToggle.addEventListener('change', function () {
            if (this.checked) {
              document.body.classList.add('challenge-mode-active');
            } else {
              document.body.classList.remove('challenge-mode-active');
            }
          });
        }

        // Code Highlighting
        highlightCodeBlocks();
        initSolutionToggles();
      });

      // ── Syntax Highlighter for ALL Code Blocks ───────────────────────
      function highlightCodeBlocks() {
        document.querySelectorAll('pre').forEach(function (preBlock) {
          // Check if already processed
          if (preBlock.querySelector('.copy-btn')) return;

          // Ensure relative positioning
          if (getComputedStyle(preBlock).position === 'static') {
            preBlock.style.position = 'relative';
          }

          // 1. Create Copy Button
          // 1. Create Copy Button
          const copyBtn = document.createElement('button');
          copyBtn.className = 'copy-btn';
          // Clean SVG Icons
          const iconCopy = '<svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" fill="currentColor"><path d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z"></path><path d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path></svg>';
          const iconCheck = '<svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" fill="currentColor"><path d="M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z"></path></svg>';

          copyBtn.innerHTML = iconCopy;
          copyBtn.ariaLabel = 'Copy code to clipboard';
          copyBtn.title = 'Copy';

          copyBtn.addEventListener('click', () => {
            const codeEl = preBlock.querySelector('code');
            const codeText = codeEl ? codeEl.innerText : preBlock.innerText;

            navigator.clipboard.writeText(codeText).then(() => {
              copyBtn.innerHTML = iconCheck;
              copyBtn.classList.add('copied');
              setTimeout(() => {
                copyBtn.innerHTML = iconCopy;
                copyBtn.classList.remove('copied');
              }, 2000);
            }).catch(err => {
              console.error('Failed to copy!', err);
            });
          });

          // Append as FIRST child to ensure it sits on top-right correctly
          if (preBlock.firstChild) {
            preBlock.insertBefore(copyBtn, preBlock.firstChild);
          } else {
            preBlock.appendChild(copyBtn);
          }

          // 2. Highlight Logic
          const codeBlock = preBlock.querySelector('code');
          if (!codeBlock) return;

          var html = codeBlock.textContent;
          // 1. Strings (light blue)
          html = html.replace(/(".*?")/g, '<span class="cs-str">$1</span>');
          // 2. Comments (grey)
          html = html.replace(/(^|\s)(#.*$)/gm, '$1<span class="cs-comment">$2</span>');
          // 3. YAML Keys (green)
          html = html.replace(/^(\s*)([\w\-\.\/]+):/gm, '$1<span class="cs-key">$2</span>:');
          // 4. Keywords
          var kws = 'apiVersion|kind|metadata|spec|status|selector|containers|volumes|template|matchLabels|strategy|replicas|serviceAccountName|nodeSelector|tolerations|resources|requests|limits|livenessProbe|readinessProbe|securityContext|capabilities|env|envFrom|volumeMounts|image|name|kubectl|k'.split('|');
          var kwRegex = new RegExp('\\b(' + kws.join('|') + ')\\b', 'g');
          html = html.replace(kwRegex, '<span class="cs-kw">$1</span>');
          // 5. Flags
          html = html.replace(/(\s)(--[\w\-]+)/g, '$1<span class="cs-flag">$2</span>');
          // 6. Section Headers
          html = html.replace(/(^# ===.*===)/gm, '<span class="cs-section">$1</span>');

          codeBlock.innerHTML = html;
        });
      }

      function initSolutionToggles() {
        document.querySelectorAll('.solution-toggle, .playground-toggle').forEach(function (btn) {
          btn.addEventListener('click', function () {
            var solution = this.nextElementSibling;
            if (!solution) return;
            var isOpen = solution.classList.toggle('is-open');
            this.setAttribute('aria-expanded', isOpen);
            this.textContent = isOpen ? 'Hide solution' : 'Show solution';
          });
        });
      }

      // ─── INTERACTIVE TERMINAL SIMULATOR ─────────────────────────────
      function initTerminal() {
        const termBtn = document.createElement('button');
        termBtn.className = 'term-fab';
        termBtn.innerHTML = '>_';
        termBtn.title = 'Open Terminal Simulator';
        document.body.appendChild(termBtn);

        const termContainer = document.createElement('div');
        termContainer.className = 'term-container';
        termContainer.innerHTML = `
          <div class="term-header">
            <span>user@cka-lab:~$</span>
            <div class="term-controls">
              <span class="term-minimize">_</span>
              <span class="term-close">×</span>
            </div>
          </div>
          <div class="term-body" id="term-body">
            <div class="term-line">Welcome to CKA Simulator v1.0</div>
            <div class="term-line">Type 'help' for available commands.</div>
            <div class="term-input-line">
              <span class="prompt">user@cka-lab:~$</span>
              <input type="text" class="term-input" autofocus>
            </div>
          </div>
        `;
        document.body.appendChild(termContainer);

        const body = termContainer.querySelector('#term-body');
        const input = termContainer.querySelector('.term-input');

        // Toggle Visibility
        termBtn.addEventListener('click', () => {
          termContainer.classList.add('open');
          termBtn.style.display = 'none';
          input.focus();
        });

        termContainer.querySelector('.term-close').addEventListener('click', () => {
          termContainer.classList.remove('open');
          termBtn.style.display = 'flex';
        });

        termContainer.querySelector('.term-minimize').addEventListener('click', () => {
          termContainer.classList.remove('open');
          termBtn.style.display = 'flex';
        });

        // Command Logic
        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            const cmd = input.value.trim();
            const cmdLine = document.createElement('div');
            cmdLine.className = 'term-line';
            cmdLine.innerHTML = `<span class="prompt">user@cka-lab:~$</span> ${cmd}`;
            body.insertBefore(cmdLine, input.parentElement); // Insert before input line

            input.value = '';
            processCommand(cmd);

            // Scroll to bottom
            body.scrollTop = body.scrollHeight;
          }
        });

        function processCommand(cmd) {
          let output = '';
          const c = cmd.toLowerCase();

          if (c === 'help') {
            output = `Available commands:
  kubectl get pods
  kubectl get nodes
  kubectl run [name] --image=[image]
  kubectl get svc
  clear`;
          } else if (c === 'clear') {
            body.innerHTML = '';
            const inputLine = document.createElement('div');
            inputLine.className = 'term-input-line';
            inputLine.innerHTML = `<span class="prompt">user@cka-lab:~$</span><input type="text" class="term-input" autofocus>`;
            body.appendChild(inputLine);
            // Re-bind listener to new input (or just clear lines above input)
            // Simpler: Just remove all .term-line elements
            document.querySelectorAll('.term-body > .term-line').forEach(el => el.remove());
            return;
          } else if (c === 'kubectl get pods' || c === 'k get po') {
            output = `NAME      READY   STATUS    RESTARTS   AGE
nginx     1/1     Running   0          5m
webapp    1/1     Running   0          2m
db-pod    0/1     Pending   0          10s`;
          } else if (c === 'kubectl get nodes' || c === 'k get no') {
            output = `NAME       STATUS   ROLES           AGE   VERSION
control    Ready    control-plane   10d   v1.30.0
worker-1   Ready    <none>          10d   v1.30.0
worker-2   Ready    <none>          10d   v1.30.0`;
          } else if (c.startsWith('kubectl run') || c.startsWith('k run')) {
            const parts = c.split(' ');
            const name = parts[2] || 'pod';
            output = `pod/${name} created`;
          } else if (c === '') {
            return;
          } else {
            output = `bash: ${cmd.split(' ')[0]}: command not found`;
          }

          if (output) {
            const outDiv = document.createElement('div');
            outDiv.className = 'term-line output';
            outDiv.innerText = output;
            body.insertBefore(outDiv, input.parentElement);
          }
        }

        // Auto-focus input when clicking anywhere in terminal
        body.addEventListener('click', () => input.focus());
      }

      initTerminal();

    })();
  </script>
</body>

</html>
